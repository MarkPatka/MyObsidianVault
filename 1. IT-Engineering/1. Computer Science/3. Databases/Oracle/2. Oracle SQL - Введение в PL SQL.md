[Краткая документация](https://oracleplsql.ru/)

**PL/SQL** — это сокращение от «Procedural Language extensions to the Structured Query Language».
## Основные характеристики PL/SQL
- Высокая структурированность, удобочитаемость и доступность.
- Стандартный переносимый язык разработки приложений для баз данных Oracle.
- Встроенный язык. PL/SQL не используется как самостоятельный язык программирования.
- Высокопроизводительный, высокоинтегрированный язык баз данных.

## PL/SQL в Oracle: Примеры основных конструкций
### Процедуры

**Процедура** - это подпрограмма, которая выполняет специфическое действие.
Процедура выполняет действия, но не возвращает значение напрямую.
#### 1. Создание процедуры (PROCEDURE)
```sql
-- Процедура для обновления зарплаты сотрудника
CREATE OR REPLACE PROCEDURE update_employee_salary(
    p_employee_id IN NUMBER,
    p_percent IN NUMBER,
    p_result OUT VARCHAR2
)
IS
    v_old_salary NUMBER;
    v_new_salary NUMBER;
BEGIN
    -- Получаем текущую зарплату
    SELECT salary INTO v_old_salary
    FROM employees
    WHERE employee_id = p_employee_id;
    
    -- Вычисляем новую зарплату
    v_new_salary := v_old_salary * (1 + p_percent / 100);
    
    -- Обновляем зарплату
    UPDATE employees
    SET salary = v_new_salary,
        last_update_date = SYSDATE
    WHERE employee_id = p_employee_id;
    
    COMMIT;
    
    -- Возвращаем результат через OUT параметр
    p_result := 'Зарплата обновлена с ' || v_old_salary || 
                ' на ' || v_new_salary;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_result := 'Сотрудник не найден';
        ROLLBACK;
    WHEN OTHERS THEN
        p_result := 'Ошибка: ' || SQLERRM;
        ROLLBACK;
END update_employee_salary;
```

```sql
-- Вызов процедуры
DECLARE
    v_result VARCHAR2(200);
BEGIN
    update_employee_salary(
        p_employee_id => 101,
        p_percent => 10,
        p_result => v_result
    );
    DBMS_OUTPUT.PUT_LINE(v_result);
END;
```

### Функции

**Функция** - это подпрограмма, которая вычисляет значение. Функция возвращает одно значение и может использоваться в SQL-запросах.

#### 2. Создание функции (FUNCTION)
```sql
-- Функция для вычисления бонуса сотрудника
CREATE OR REPLACE FUNCTION calculate_bonus(
    p_employee_id IN NUMBER,
    p_bonus_rate IN NUMBER DEFAULT 0.15
)
RETURN NUMBER
IS
    v_salary NUMBER;
    v_years_worked NUMBER;
    v_bonus NUMBER;
BEGIN
    -- Получаем зарплату и стаж
    SELECT 
        salary,
        ROUND(MONTHS_BETWEEN(SYSDATE, hire_date) / 12, 1)
    INTO v_salary, v_years_worked
    FROM employees
    WHERE employee_id = p_employee_id;
    
    -- Вычисляем бонус с учетом стажа
    IF v_years_worked >= 10 THEN
        v_bonus := v_salary * p_bonus_rate * 1.5;
    ELSIF v_years_worked >= 5 THEN
        v_bonus := v_salary * p_bonus_rate * 1.2;
    ELSE
        v_bonus := v_salary * p_bonus_rate;
    END IF;
    
    RETURN ROUND(v_bonus, 2);
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 0;
    WHEN OTHERS THEN
        RETURN -1;
END calculate_bonus;
```

```sql
-- Использование функции в запросе
SELECT 
    employee_id,
    first_name || ' ' || last_name AS full_name,
    salary,
    calculate_bonus(employee_id) AS bonus,
    salary + calculate_bonus(employee_id) AS total_compensation
FROM employees
WHERE department_id = 50
ORDER BY total_compensation DESC;

-- Использование в блоке PL/SQL
DECLARE
    v_bonus NUMBER;
BEGIN
    v_bonus := calculate_bonus(101, 0.20);
    DBMS_OUTPUT.PUT_LINE('Бонус сотрудника: ' || v_bonus);
END;
```


### Триггеры

**Триггер** является именованным модулем PL/SQL, который хранится в базе данных и может быть вызван повторно. Триггер автоматически выполняется при определенных событиях.

**Классификация по времени и объекту:**

- По времени выполнения
    - BEFORE триггер — выполняется до DML (INSERT/UPDATE/DELETE).
    - AFTER триггер — выполняется после DML.
    - INSTEAD OF — для виртуальных представлений (view); выполняет вместо DML на view.
- По уровню
    - Row-level (FOR EACH ROW) — срабатывает для каждой строки; доступны :OLD и :NEW.
    - Statement-level — срабатывает один раз на DML оператор, без :OLD/:NEW.
- По событию
    - INSERT, UPDATE, DELETE — отдельные или комбинированные (e.g., AFTER INSERT OR UPDATE).
    - DDL триггеры (ON DATABASE or ON SCHEMA) — события CREATE, ALTER, DROP и т.д.
    - Database-level triggers — логон/логоф (LOGON, LOGOFF), ERROR, SERVERERROR, STARTUP, SHUTDOWN и др.
#### 3. Создание и использование триггера (TRIGGER)
```sql
-- Создаем таблицу для логирования
CREATE TABLE salary_audit_log (
    log_id NUMBER PRIMARY KEY,
    employee_id NUMBER,
    old_salary NUMBER,
    new_salary NUMBER,
    change_date DATE,
    changed_by VARCHAR2(50),
    change_percent NUMBER
);

CREATE SEQUENCE salary_audit_seq START WITH 1;

-- Триггер для аудита изменений зарплаты
CREATE OR REPLACE TRIGGER trg_salary_audit
AFTER UPDATE OF salary ON employees
FOR EACH ROW
WHEN (OLD.salary != NEW.salary)
DECLARE
    v_change_percent NUMBER;
BEGIN
    -- Вычисляем процент изменения
    v_change_percent := ROUND(
        ((:NEW.salary - :OLD.salary) / :OLD.salary) * 100, 
        2
    );
    
    -- Записываем в лог
    INSERT INTO salary_audit_log (
        log_id,
        employee_id,
        old_salary,
        new_salary,
        change_date,
        changed_by,
        change_percent
    ) VALUES (
        salary_audit_seq.NEXTVAL,
        :NEW.employee_id,
        :OLD.salary,
        :NEW.salary,
        SYSDATE,
        USER,
        v_change_percent
    );
    
    -- Предупреждение о большом изменении
    IF ABS(v_change_percent) > 50 THEN
        DBMS_OUTPUT.PUT_LINE(
            'ВНИМАНИЕ: Изменение зарплаты на ' || 
            v_change_percent || '% для сотрудника ' || 
            :NEW.employee_id
        );
    END IF;
END;
```

```sql
-- Тест триггера
UPDATE employees
SET salary = salary * 1.15
WHERE employee_id = 101;

-- Просмотр лога
SELECT * FROM salary_audit_log ORDER BY change_date DESC;
```
### Коллекции

Составной тип данных хранит значения, которые имеют внутренние компоненты. Вы можете передать целые составные переменные подпрограммам в качестве параметров, а также получить доступ к внутренним компонентам составных переменных по отдельности. Внутренние компоненты могут быть скалярными или составными. Вы можете использовать скалярные компоненты везде, где вы можете использовать скалярные переменные. PL/SQL позволяет вам определять два вида составных типов данных: коллекция и запись. Вы можете использовать составные компоненты везде, где вы можете использовать составные переменные одного типа.

**Типы коллекций**:

1. **Associative array (index-by table)**
	Используется для кэширования, временных хэшей, передач между курсорами.
2. **Nested table**
	Преимущества: можно мультистрочно вставлять в SQL через TABLE().
3. **VARRAY (variable-size array)**
	Используется когда нужен упорядоченный массив с ограничением размера.
#### 4. Создание коллекции и записи (COLLECTION & RECORD)
```sql
DECLARE
    -- Определение типа записи
    TYPE emp_record_type IS RECORD (
        emp_id employees.employee_id%TYPE,
        full_name VARCHAR2(100),
        salary employees.salary%TYPE,
        dept_name departments.department_name%TYPE
    );
    
    -- Определение типа коллекции (таблица записей)
    TYPE emp_table_type IS TABLE OF emp_record_type
        INDEX BY PLS_INTEGER;
    
    -- Переменные
    v_emp_record emp_record_type;
    v_emp_table emp_table_type;
    v_index PLS_INTEGER := 1;
    
BEGIN
    -- Заполнение коллекции данными
    FOR emp IN (
        SELECT 
            e.employee_id,
            e.first_name || ' ' || e.last_name AS full_name,
            e.salary,
            d.department_name
        FROM employees e
        JOIN departments d ON e.department_id = d.department_id
        WHERE e.salary > 5000
        ORDER BY e.salary DESC
        FETCH FIRST 5 ROWS ONLY
    ) LOOP
        v_emp_table(v_index).emp_id := emp.employee_id;
        v_emp_table(v_index).full_name := emp.full_name;
        v_emp_table(v_index).salary := emp.salary;
        v_emp_table(v_index).dept_name := emp.department_name;
        
        v_index := v_index + 1;
    END LOOP;
```

```sql
    -- Вывод данных из коллекции
    DBMS_OUTPUT.PUT_LINE('Топ-5 сотрудников по зарплате:');
    DBMS_OUTPUT.PUT_LINE('================================');
    
    FOR i IN 1..v_emp_table.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE(
            'ID: ' || v_emp_table(i).emp_id || 
            ', Имя: ' || v_emp_table(i).full_name ||
            ', Зарплата: ' || v_emp_table(i).salary ||
            ', Отдел: ' || v_emp_table(i).dept_name
        );
    END LOOP;
    
    -- Работа с одной записью
    v_emp_record := v_emp_table(1);
    DBMS_OUTPUT.PUT_LINE('');
    DBMS_OUTPUT.PUT_LINE('Лучший сотрудник: ' || v_emp_record.full_name);
    
END;
```
### Курсоры

**Курсор** (CURSOR) - это набор строк, возвращаемых запросом, может состоять из нуля, одной или нескольких строк, в зависимости от того, сколько строк соответствует вашим критериям поиска. Когда запрос возвращает несколько строк, вы можете явно объявить курсор для обработки строк. Более того, вы можете объявить курсор в декларативной части любого PL/SQL-блока, подпрограммы или пакета.

#### 5. Создание и использование курсора (CURSOR)
```sql
DECLARE
    -- Объявление курсора с параметром
    CURSOR cur_dept_employees(p_dept_id NUMBER) IS
        SELECT 
            employee_id,
            first_name || ' ' || last_name AS full_name,
            salary,
            hire_date,
            ROUND(MONTHS_BETWEEN(SYSDATE, hire_date) / 12, 1) AS years
        FROM employees
        WHERE department_id = p_dept_id
        ORDER BY salary DESC;
    
    -- Переменная для строки курсора
    v_emp_rec cur_dept_employees%ROWTYPE;
    
    -- Переменные для статистики
    v_total_salary NUMBER := 0;
    v_emp_count NUMBER := 0;
    v_dept_name departments.department_name%TYPE;
    
BEGIN
    -- Получаем название отдела
    SELECT department_name INTO v_dept_name
    FROM departments
    WHERE department_id = 50;
    
    DBMS_OUTPUT.PUT_LINE('Отчет по отделу: ' || v_dept_name);
    DBMS_OUTPUT.PUT_LINE('========================================');
    
    -- Открываем курсор
    OPEN cur_dept_employees(50);
    
    -- Обходим курсор
    LOOP
        FETCH cur_dept_employees INTO v_emp_rec;
        EXIT WHEN cur_dept_employees%NOTFOUND;
        
        v_emp_count := v_emp_count + 1;
        v_total_salary := v_total_salary + v_emp_rec.salary;
        
        DBMS_OUTPUT.PUT_LINE(
            v_emp_count || '. ' || v_emp_rec.full_name ||
            ' - Зарплата: ' || v_emp_rec.salary ||
            ', Стаж: ' || v_emp_rec.years || ' лет'
        );
    END LOOP;
    
    -- Закрываем курсор
    CLOSE cur_dept_employees;
    
    -- Выводим статистику
    DBMS_OUTPUT.PUT_LINE('========================================');
    DBMS_OUTPUT.PUT_LINE('Всего сотрудников: ' || v_emp_count);
    DBMS_OUTPUT.PUT_LINE('Общий фонд зарплат: ' || v_total_salary);
    DBMS_OUTPUT.PUT_LINE('Средняя зарплата: ' || 
        ROUND(v_total_salary / v_emp_count, 2));
    
EXCEPTION
    WHEN OTHERS THEN
        IF cur_dept_employees%ISOPEN THEN
            CLOSE cur_dept_employees;
        END IF;
        DBMS_OUTPUT.PUT_LINE('Ошибка: ' || SQLERRM);
END;
```

```sql
-- Пример с курсором FOR LOOP (более простой способ)
BEGIN
    DBMS_OUTPUT.PUT_LINE('Сотрудники с зарплатой > 10000:');
    
    FOR emp IN (
        SELECT employee_id, 
               first_name || ' ' || last_name AS name, 
               salary
        FROM employees
        WHERE salary > 10000
        ORDER BY salary DESC
    ) LOOP
        DBMS_OUTPUT.PUT_LINE(
            emp.name || ': $' || emp.salary
        );
    END LOOP;
END;
```
### Пакеты

**Пакет в Oracle PL/SQL** набор элементов: процедур, функций, определения типов; объявления переменных, констант можно объединить в пакет. После написания пакет PL/SQL компилируется, а затем сохраняется в базе данных Oracle, где его содержимое может использоваться многими приложениями.

**Пакет Oracle PL/SQL** - это объект схемы, который группирует логически связанные типы, элементы и подпрограммы. Пакеты обычно состоят из двух частей: спецификации и тела, хотя иногда тело не нужно. Спецификация - это интерфейс для ваших приложений. 

В _спeцификации_ пакета объявляются типы, переменные, константы, исключения, курсоры и подпрограммы, доступные для использования.  
_Тело_ пакета полностью определяет курсоры и подпрограммы и реализует спецификацию.

![[package.png]]

Как показано на рисунке, вы можете думать о спецификации как о рабочем интерфейсе, а о теле - как о «черном ящике». Вы можете отлаживать, улучшать или изменять тело пакета без изменения интерфейса (спецификации) пакета.
#### 6. Создание пакета (PACKAGE)
```sql
CREATE OR REPLACE PACKAGE emp_actions AS  -- спецификация
   TYPE EmpRecTyp IS RECORD (emp_id INT, salary REAL); -- тип запись
   CURSOR desc_salary RETURN EmpRecTyp;                -- курсор
   /*процедура приема на работу*/
   PROCEDURE hire_employee (
      ename  VARCHAR2,
      job    VARCHAR2,
      mgr    NUMBER,
      sal    NUMBER,
      comm   NUMBER,
      deptno NUMBER);
      
   /*процедура увольнения*/   
   PROCEDURE fire_employee (emp_id NUMBER);
END emp_actions;

CREATE OR REPLACE PACKAGE BODY emp_actions AS  -- тело
   CURSOR desc_salary RETURN EmpRecTyp IS
      SELECT empno, sal FROM emp ORDER BY sal DESC;
   PROCEDURE hire_employee (
      ename  VARCHAR2,
      job    VARCHAR2,
      mgr    NUMBER,
      sal    NUMBER,
      comm   NUMBER,
      deptno NUMBER) IS
   BEGIN
      INSERT INTO emp VALUES (empno_seq.NEXTVAL, ename, job,
         mgr, SYSDATE, sal, comm, deptno);
   END hire_employee;
   PROCEDURE fire_employee (emp_id NUMBER) IS
   BEGIN
      DELETE FROM emp WHERE empno = emp_id;
   END fire_employee;
END emp_actions;
```

