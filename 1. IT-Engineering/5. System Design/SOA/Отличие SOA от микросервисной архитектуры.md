## SOA (Service-Oriented Architecture)

В основе лежат несколько основных идей – переиспользование сервисов и корпоративная шина. Разработчики стремятся разбить систему на сервисы таким образом, чтобы их можно было использовать повторно. Взаимодействие и маршрутизация осуществляется через корпоративную шину ESB. Типичная SOA архитектура показана на рисунке ниже.  

![[SOA_.png.webp]]

## SOA архитектура

Давайте посмотрим из каких частей она состоит, и какова их роль.  
  
**Шина(ESB)**: в случае взаимодействия сложных событий действует как посредник и управляет различными рутинными операциями, такими как передача сообщений и координация вызовов.  
  
**Инфраструктурные сервисы (infrastructure services)**: группа легко переиспользуемых сервисов, таких как аутентификация/авторизация, отправка смс и прочее.  
  
**Прикладные сервисы (application services)**: не могут быть переиспользованны под разные задачи, так как ограничены определенным прикладным контекстом, но их можно встраивать в более высокоуровневые сервисы.  
  
**Сервисы предприятия (Enterprise services)**: эти сервисы отвечают за реализацию крупных частей бизнес процессов компании, они потребляют более низкоуровневые сервисы.  
  
**API**: по сути это бэкенды, предоставляющие API, доступное в интернет, для сайтов и мобильных приложений компании. Они взаимодействуют с ESB и раскрывают функциональность для конечных потребителей.  
  
Как вы могли заметить, проектируя архитектуру в данном стиле, мы имеем очень большое количество слоев и как следствие команд, которые ими владеют. Любой запрос пронизывает все слои системы, в большей степени напоминая монолитную архитектуру. Но данный тип архитектуры намного сложнее, потому что является распределенной архитектурой.  

## MSA (microservices)

Микросервисы в отличие от SOA, наоборот, избегают повторного использования, применяя философию - предпочтительнее дублирование, а не зависимость от других сервисов. Повторное использование предполагает связанность, а архитектура микросервисов в значительной степени старается ее избегать. Это достигается за счет разбиения системы на сервисы по ограниченным контекстам (бизнес областям). Типичная MSA архитектура показана на рисунке ниже.  

![[MSA_1.png.webp]]

В отличие от SOA каждый сервис обладает всеми необходимыми для функционирования частями – имеет свою собственную базу данных и существует как независимый процесс. Такая архитектура делает каждый сервис физически разделенным, самодостаточным, что ведет с технической точки зрения к архитектуре без разделения ресурсов.  
  
Сервисы раскрываются для потребителей также через слой API, но его стараются проектировать с полным отсутствием какой-либо логики. Это фактически просто проксирование API сервисов во вне.  
  
Взаимодействие между сервисами сводится к обмену данными, используя брокер сообщений. Именно к обмену данными, а не вызову методов из других сервисов.


## Основные принципы сервис-ориентированной архитектуры


Сервис-ориентированная архитектура строится на нескольких ключевых принципах. Эти принципы служат фундаментом для создания и управления сервисами в рамках SOA и определяют, как именно сервисы взаимодействуют между собой и с внешними системами.

### **Повторное использование сервисов**

Один из основных принципов SOA заключается в возможности повторного использования сервисов. Это означает, что один и тот же сервис может быть использован в различных приложениях и контекстах без необходимости его модификации. Например, сервис аутентификации может быть задействован как в веб-приложении, так и в мобильном приложении, обеспечивая единое решения для управления доступом

### **Автономность**

Принцип автономности подразумевает, что каждый сервис должен быть независимым и самодостаточным. Сервисы способны работать обособленно друг от друга и не должны зависеть от конкретной реализации других сервисов. Такая независимость позволяет разработчикам обновлять и изменять сервисы без риска нарушения работы всей системы.

### **Стандартизированные контракты**

Сервисы в SOA взаимодействуют друг с другом через стандартизированные контракты. Эти контракты определяют, какие данные могут передаваться между сервисами и как эти данные должны быть структурированы. Стандартизация упрощает интеграцию сервисов и обеспечивает согласованность во взаимодействии. Часто используются протоколы и стандарты, такие как SOAP и REST.

### **Композиция сервисов**

Принцип композиции сервисов предполагает возможность объединения нескольких сервисов для создания более сложных бизнес-процессов и приложений. Композиция позволяет гибко настраивать и изменять функциональность системы без необходимости переписывания отдельных компонентов. Например, можно создать бизнес-процесс, который использует сервисы для обработки заказов, управления клиентами и управления складом.

### **Интероперабельность**

Интероперабельность означает, что сервисы могут взаимодействовать друг с другом, независимо от платформы, языка программирования или технологии, на которых они построены. Это достигается за счет использования общепринятых стандартов и протоколов, что позволяет интегрировать сервисы, разработанные различными командами и работающие в различных средах.

Эти принципы обеспечивают основу для разработки гибких, масштабируемых и легко поддерживаемых программных систем в рамках сервис-ориентированной архитектуры. Внедрение и соблюдение этих принципов позволяет организациям создавать устойчивые решения, способные быстро адаптироваться к изменяющимся бизнес-требованиям и технологическим изменениям. 

## Схема SOA

Схема SOA обычно включает в себя следующие основные компоненты: сервисы, потребители сервисов, корпоративная сервисная шина, репозиторий сервисов, а также различные инструменты для управления и мониторинга. Рассмотрим каждый из этих компонентов более подробно:

- **Сервисы**. Являются основными строительными блоками SOA. Каждый сервис представляет собой автономную функциональную единицу, которая предоставляет определенные возможности или данные. Сервисы могут быть разного типа, включая бизнес-сервисы, инфраструктурные сервисы и композитные сервисы, которые объединяют несколько других сервисов для выполнения более сложных задач.
  
- **Потребители сервисов** — это приложения или другие сервисы, которые используют функциональность, предоставляемую сервисами. Потребители могут взаимодействовать с сервисами через стандартизированные интерфейсы и протоколы. Например, это веб-приложения, мобильные приложения, другие бизнес-сервисы или внешние системы.
  
- **Корпоративная сервисная шина** (ESB). Является важным компонентом SOA, который обеспечивает взаимодействие между сервисами. Она выполняет функции маршрутизации сообщений, трансформации данных, оркестрации сервисов и управления интеграцией. ESB обеспечивает надежную доставку сообщений и управление транзакциями.
  
- **Репозиторий сервисов** хранит метаданные о сервисах, такие как их описания, контракты, схемы и политики. Это позволяет легко находить и повторно использовать существующие сервисы. Репозиторий помогает управлять версиями сервисов, отслеживать их зависимости и обеспечивать соответствие стандартам и политикам.
  
- **Управление и мониторинг**. Инструменты управления и мониторинга играют ключевую роль в SOA, обеспечивая контроль за состоянием и производительностью сервисов, а также управление конфигурацией.

![[SOA_2.jpg]]

Эта схема иллюстрирует, как различные компоненты SOA взаимодействуют друг с другом для формирования гибкой и масштабируемой системы. Осознание этих компонентов и их взаимодействий позволяет разработчикам и архитекторам использовать преимущества сервис-ориентированной архитектуры и строить надежные, крепкие системы.

## Основные принципы микросервисной архитектуры

Микросервисная архитектура основывается на нескольких ключевых принципах, которые направлены на повышение гибкости, масштабируемости и независимости компонентов системы. Эти принципы являются фундаментом для проектирования, разработки и управления микросервисами, обеспечивая их эффективное взаимодействие и интеграцию в рамках сложных программных систем.

### **Однозначная ответственность**

Каждый микросервис выполняет одну конкретную функцию или задачу и отвечает за определенную область бизнес-логики. Это позволяет достичь высокой степени модульности и четкого разделения ответственности. Например, микросервис для управления пользователями отвечает только за создание, обновление и удаление пользовательских учетных записей, не вмешиваясь в обработку заказов или управление продуктами.

### **Независимое развертывание**

Микросервисы разрабатываются и развертываются независимо друг от друга. Это позволяет обновлять и масштабировать каждый микросервис без необходимости останавливать всю систему. Обновление микросервиса для обработки платежей не требует остановки микросервиса для управления пользователями, что минимизирует время простоя и снижает риски. 

### **Автономность**

Микросервисы должны быть автономными, что означает, что каждый из них может работать независимо от других. Это достигается за счет минимизации взаимозависимостей и использования четко определенных интерфейсов для взаимодействия. Микросервис для управления продуктами может работать независимо от микросервиса для обработки заказов, взаимодействуя с ним только через REST API или другие протоколы.

## **Центричность на задачах для бизнеса**

Каждый микросервис фокусируется на реализации конкретной бизнес-задачи, что позволяет лучше соответствовать требованиям и быстро адаптироваться к изменениям. Микросервис для управления скидками реализует только функциональность, связанную с созданием и применением скидок, что упрощает его разработку и поддержку. 

## **Децентрализованное управление данными**

Каждый микросервис управляет своей собственной базой данных или хранилищем данных. Это обеспечивает независимость данных и улучшает производительность за счет уменьшения конкуренции за ресурсы. 

## **Согласованность и устойчивость**

Микросервисы должны обеспечивать согласованность данных и устойчивость к ошибкам. Это достигается за счет использования шаблонов проектирования.

Принципы микросервисной архитектуры направлены на создание гибких, масштабируемых и легко управляемых систем. Внедрение и соблюдение этих принципов позволяет организациям быстро адаптироваться к изменениям, масштабировать свои решения и поддерживать высокое качество программного обеспечения. Понимание и применение этих принципов является ключом к успешному внедрению микросервисной архитектуры и достижению ее преимуществ. 

## Схема микросервисной архитектуры

Ниже описаны ключевые компоненты и схема микросервисной архитектуры

- **Микросервисы** — набор автономных сервисов, каждый из которых отвечает за выполнение одной бизнес-функции. Микросервисы взаимодействуют друг с другом через API, используя протоколы HTTP/REST или Message Brokers.

- **API Gateway** служит единой точкой входа для всех запросов к микросервисам. Он маршрутизирует запросы к соответствующим микросервисам, управляет аутентификацией и авторизацией, а также выполняет другие задачи, связанные с ограничением скорости и балансировкой нагрузки.

- **Discovery**. Механизм, позволяющий микросервисам находить друг друга в сети. Сервис Discovery отслеживает расположение и статус всех микросервисов.

- **Балансировщик нагрузки** распределяет входящие запросы между экземплярами микросервисов для обеспечения высокой доступности и масштабируемости.

- **Хранилище данных**. Каждый микросервис управляет своей собственной базой данных или хранилищем данных, что обеспечивает децентрализованное управление.

- **Message Broker** обеспечивает асинхронное взаимодействие между микросервисами, позволяя им обмениваться сообщениями и событиями.

- **Инструменты для мониторинга и логирования**, которые помогают отслеживать состояние, производительность и логи каждого микросервиса.
  
![[MSA_2.jpg]]
Микросервисная архитектура обеспечивает высокую гибкость, масштабируемость и независимость компонентов системы за счет разделения бизнес-логики на мелкие, автономные сервисы. Применение этих принципов позволяет создавать надежные и продуктивные системы, способные быстро адаптироваться к изменяющимся требованиям.
## Сравнение архитектурных подходов

### Ключевые различия подходов:

| **Подход/параметр**          | **SOA**                                                                                                                                    | **Микросервисы**                                                                                                                                         |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **«Гранулярность» сервисов** | Сервисы могут быть крупными и часто реализуют значительную часть бизнес-логики. Они более комплексные и охватывают широкий спектр функций. | Ориентированы на мелкозернистость. Каждый микросервис выполняет одну конкретную функцию или задачу, что делает их более модульными и легко управляемыми. |
| **Коммуникация**             | Обычно взаимодействуют через ESB, которая обеспечивает маршрутизацию, трансформацию и оркестрацию сообщений.                               | Используют легковесные протоколы коммуникации, такие как HTTP/REST, что упрощает взаимодействие и уменьшает задержки.                                    |
| **Деплой**                   | Сервисы в SOA часто развертываются вместе и могут зависеть друг от друга, что усложняет процесс обновления и масштабирования.              | Каждый микросервис развертывается независимо, что позволяет обновлять, масштабировать и тестировать их автономно, не влияя на другие части системы.      |
### Преимущества и недостатки

|                                                                                       | **Преимущества**                                                               | **Недостатки**                                         |
| ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ------------------------------------------------------ |
| **SOA**                                                                               | Повторное использование сервисов благодаря стандартизированным контрактам      | Сложность и стоимость внедрения, а также поддержки ESB |
| Централизованное управление и контроль через ESB                                      | Медленная реакция на изменения из-за крупнозернистости сервисов                |                                                        |
| Хорошо подходит для крупномасштабных корпоративных систем с комплексными интеграциями | Возможные узкие места и точки отказа ESB                                       |                                                        |
| **Микросервисы**                                                                      | Быстрая разработка и развертывание благодаря независимости                     | Сложность управления распределенной системой           |
| Высокая гибкость и масштабируемость                                                   | Потенциальные проблемы с согласованностью данных                               |                                                        |
| Легкость внедрения новых технологий и инструментов                                    | Увеличение числа сервисов может привести к проблемам с мониторингом и отладкой |                                                        |

## Сравним подробнее SOA и MSA с точки зрения развития и поддержки системы.

### **Внесение изменений**

#### **SOA**  
Выполнять изменения в архитектуре SOA чрезвычайно трудно, зачастую для внесения одного изменения требуется изменения сразу в нескольких сервисах. Так как отдельными сервисами владеют разные команды, то внесение элементарных изменений превращается в сущий ад из бесконечных совещаний, согласований и документов.  
  
Если две разные команды используют один общий сервис, то при изменении этого сервиса нужно будет учитывать влияние на сервисы обеих команд. Когда таких зависимостей много, развивать сервис становиться очень трудно.  
  
#### **MSA**.  
Так как в микросервисной архитектуре зависимости от других сервисов отсутствуют либо минимальны, то необходимость взаимодействия с другими сервисами и командами пропадает. Внесение изменений осуществляется командой, которая владеет сервисом. Изменения происходят легче и быстрее.  

### **Переиспользование**

#### **SOA**  
Стремление к переиспользованию. Но, к сожалению, разработчики часто тратят много времени, пытаясь интегрировать повторно используемые сервисы, которые, как оказывается, мало используются повторно. В конечном итоге мы приходим к ситуации - чем больше у сервиса возможностей для повторного применения, тем менее пригодным к применению он становится.  
  
#### **MSA**  
Может возникнуть ситуация, когда два разных сервиса используют одну и ту же сущность, к примеру «Customer». В микросервисной архитектуре предпочтительнее использовать дублирование. То есть создать в каждом сервисе свою реализацию «Customer», что позволит развивать оба сервиса независимо.  
  
Есть большая вероятность, что спустя время в одном из сервисов изменятся бизнес правила или структура объекта «Customer», но так как в двух сервисах сущность дублируется, то на другой сервис это не окажет никакого влияния. Оба сервиса все так же могут развиваться независимо.

### **Команды и поддержка**

#### **SOA**  
Большинство команд архитектуры SOA разделены так же, как архитектура, и требуются колоссальные усилия координации для простых изменений. В основном это связано с тем, что большинство из команд не владеет процессом от начала до конца, а лишь развивает сервисы, которые являются его частями. Как следствие они не понимают и не отвечают за процесс целиком.  
  
#### **MSA**  
Команда кроссфункциональна, то есть включает в себя всех специалистов, необходимых для развития сервиса. Так как сервис реализует процесс от и до, то команда владеет процессом от начала до конца. Как следствие они понимают и отвечают за процесс целиком. И да, за часть фронтенда, в рамках сервиса, так же отвечает команда.

### **Взаимодействие**

#### **SOA**  
Взаимодействие осуществляется через корпоративную шину. Если в ней со временем появляется много логики, то она легко становится бутылочным горлышком.  
  
#### **MSA**  
Каждый сервис обладает всеми частями своего ограниченного контекста и осуществляет связь с другими ограниченными контекстами с помощью обмена данными, используя брокер сообщений. Просто обмен, никакой сложной логики.

### **Автоматизация и развертывание**

#### **SOA**  
Архитектуру SOA на основе событий сложно ввести в эксплуатацию. Эта архитектура состоит из множества развертываемых модулей, что затрудняет процесс автоматизации и координации.  
  
#### **MSA**  
Сервис может быть развернут независимо от других сервисов (и другой инфраструктуры), что отражает ограниченный контекст. Возможность для разработчика развертывать один сервис, не оказывая влияния на другой, является одним из преимуществ архитектуры этого типа.

### **Тестирование**

#### **SOA**  
Тестирование архитектуры SOA затруднено. Ни одна из частей архитектуры не является завершенной — все они являются частью более крупного рабочего потока и обычно не предназначены для изолированного тестирования. Провести end-to-end тестирование такой системы, практически нереально.  
  
#### **MSA**  
Так как каждый сервис имеет хорошо определенную границу и минимум зависимостей, это позволяет легко тестировать сервис в изоляции от других частей системы. Подготовка тестовых данных и управление ими так же облегчена, так как они находятся под контролем той же команды, что разрабатывает сам сервис. Не многочисленные зависимости сервиса (БД, брокер сообщений) легко мокируются.

## **Итоги**

Архитектуры программного обеспечения создаются не в вакууме, а как ответ на окружающую среду, учитывая различные ограничения среды. 10 лет назад не были так популярны системы с открытым исходным кодом, не было Docker, приложения разворачивались на дорогих железных серверах. Вся инфраструктура была коммерческой, лицензионной и дорогостоящей. SOA была оптимальна для оптимизации и утилизации инфраструктуры, отсюда и такая тяга к переиспользованию.  
  
Сейчас большая часть программного стека имеет открытый исходный код, лицензирование и другие проблемы больше не влияют на архитектуру. Системы непрерывного развертывания и движение DevOps позволяют легко управлять и создавать сотни независимых сервисов.  
  
Важно понимать, что различие между двумя подходами не столько техническое, сколько концептуальное. Если вы убрали ESB, но при этом все еще стремитесь к переиспользованию, и у вас много зависимостей между сервисами, то такую архитектуру нельзя назвать микросервисной.

