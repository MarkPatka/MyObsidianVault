## **Контекст**

Команда в сервисе обычно должна создавать/обновлять/удалять агрегаты в базе данных и отправлять сообщения/события в брокер сообщений. Например, сервис, участвующий в саге, должен обновлять бизнес-сущности и отправлять сообщения/события. Аналогично, сервис, публикующий [[Domain Event]], должен обновить 
[[Aggregate|Агрегат]] и опубликовать событие.

Команда должна атомарно обновить базу данных и отправить сообщения, чтобы избежать противоречивости данных и ошибок. Однако использование традиционной распределенной транзакции ([[Two-Phase Commit (2PC)|2PC ]]), охватывающей базу данных и брокер сообщений, нецелесообразно. База данных и/или брокер сообщений могут не поддерживать [[Two-Phase Commit (2PC)|2PC ]]. И даже если поддерживают, часто нежелательно связывать сервис как с базой данных, так и с брокером сообщений.

Но без использования [[Two-Phase Commit (2PC)|2PC ]] отправка сообщения в середине транзакции ненадежна. Нет гарантии, что транзакция будет зафиксирована. Аналогично, если сервис отправляет сообщение после фиксации транзакции, нет гарантии, что он не завершится аварийно до отправки сообщения.

Кроме того, сообщения должны отправляться в брокер сообщений в том же порядке, в котором их отправил сервис. Они обычно должны доставляться каждому потребителю в одном и том же порядке, хотя это выходит за рамки данного шаблона. Например, предположим, что агрегат обновляется серией транзакций T1, T2 и т.д. Эти транзакции могут выполняться одним и тем же экземпляром сервиса или разными экземплярами. Каждая транзакция публикует соответствующее событие: T1 -> E1, T2 -> E2 и т.д. Поскольку T1 предшествует T2, событие E1 должно быть опубликовано до E2.

## **Проблема**

Как атомарно обновить базу данных и отправить сообщения в брокер сообщений?

## **Требования**

* 2PC не подходит. База данных и/или брокер сообщений могут не поддерживать 2PC. Кроме того, часто нежелательно связывать сервис как с базой данных, так и с брокером сообщений.
* Если транзакция в базе данных фиксируется, то сообщения должны быть отправлены. И наоборот, если транзакция в базе данных откатывается, сообщения отправлены быть не должны.
* Сообщения должны отправляться в брокер сообщений в том же порядке, в котором их отправил сервис. Этот порядок должен сохраняться при обновлении одного и того же агрегата разными экземплярами сервиса.

## **Решение**

Хорошим решением этой проблемы является использование **источников событий (Event Sourcing)**. Источники событий сохраняют состояние бизнес-сущности, такой как Заказ (Order) или Клиент (Customer), в виде последовательности событий, изменяющих состояние. Всякий раз, когда состояние бизнес-сущности изменяется, новое событие добавляется в список событий. Поскольку сохранение события — это одна операция, оно по своей природе атомарно. Приложение восстанавливает текущее состояние сущности, воспроизводя события.

Приложения сохраняют события в **хранилище событий (event store)**, которое является базой данных событий. Хранилище предоставляет API для добавления и извлечения событий сущности. Хранилище событий также ведет себя как брокер сообщений. Оно предоставляет API, который позволяет сервисам подписываться на события. Когда сервис сохраняет событие в хранилище событий, оно доставляется всем заинтересованным подписчикам.

У некоторых сущностей, например, Клиента (Customer), может быть очень большое количество событий. Чтобы оптимизировать загрузку, приложение может периодически сохранять **снимок состояния (snapshot)** текущего состояния сущности. Чтобы восстановить текущее состояние, приложение находит самый последний снимок и события, произошедшие после этого снимка. В результате нужно воспроизвести меньше событий.

## **Пример** (нуждается в доработке - большей наглядности)

На следующей диаграмме показано, как некое приложение сохраняет заказы.
![[OrderServer_event_sourcing_demo.png]]
Вместо простого хранения текущего состояния каждого заказа в виде строки в таблице ORDERS, приложение сохраняет каждый Заказ как последовательность событий. CustomerService может подписаться на события заказов и обновлять собственное состояние.

Вот агрегат (Order):
```csharp
public class Order : AggregateRoot
{
    public OrderState State { get; private set; }
    public string CustomerId { get; private set; }
    
    public Order()
    {
        // Конструктор для восстановления из событий
    }
    
    // Команды (процессоры команд)
    public void Create(CreateOrderCommand command)
    {
        Apply(new OrderCreatedEvent(
            command.OrderId,
            command.CustomerId, 
            command.OrderTotal,
            DateTime.UtcNow
        ));
    }
    
    public void Approve()
    {
        Apply(new OrderApprovedEvent(
            Id,
            CustomerId,
            DateTime.UtcNow
        ));
    }
    
    public void Reject()
    {
        Apply(new OrderRejectedEvent(
            Id,
            CustomerId,
            DateTime.UtcNow
        ));
    }
    
    // Обработчики событий (изменяют состояние)
    protected void When(OrderCreatedEvent @event)
    {
        Id = @event.OrderId;
        CustomerId = @event.CustomerId;
        State = OrderState.Created;
    }
    
    protected void When(OrderApprovedEvent @event)
    {
        State = OrderState.Approved;
    }
    
    protected void When(OrderRejectedEvent @event)
    {
        State = OrderState.Rejected;
    }
}

// Состояния заказа
public enum OrderState
{
    Created,
    Approved,
    Rejected,
    Cancelled
}

// СОБЫТИЯ
public abstract class DomainEvent
{
    public Guid EventId { get; } = Guid.NewGuid();
    public DateTime OccurredOn { get; protected set; } = DateTime.UtcNow;
}

public class OrderCreatedEvent : DomainEvent
{
    public Guid OrderId { get; }
    public string CustomerId { get; }
    public decimal OrderTotal { get; }
    
    public OrderCreatedEvent(Guid orderId, string customerId, decimal orderTotal, DateTime occurredOn)
    {
        OrderId = orderId;
        CustomerId = customerId;
        OrderTotal = orderTotal;
        OccurredOn = occurredOn;
    }
}

public class OrderApprovedEvent : DomainEvent
{
    public Guid OrderId { get; }
    public string CustomerId { get; }
    
    public OrderApprovedEvent(Guid orderId, string customerId, DateTime occurredOn)
    {
        OrderId = orderId;
        CustomerId = customerId;
        OccurredOn = occurredOn;
    }
}

public class OrderRejectedEvent : DomainEvent
{
    public Guid OrderId { get; }
    public string CustomerId { get; }
    
    public OrderRejectedEvent(Guid orderId, string customerId, DateTime occurredOn)
    {
        OrderId = orderId;
        CustomerId = customerId;
        OccurredOn = occurredOn;
    }
}
```
Вот пример обработчика событий в CustomerService, который подписывается на события Заказов:
```csharp
using System.Threading.Tasks;

[EventSubscriber(Id = "customerWorkflow")]
public class CustomerWorkflow
{
    [EventHandlerMethod]
    public async Task<EntityWithIdAndVersion<Customer>> ReserveCreditAsync(
        EventHandlerContext<OrderCreatedEvent> ctx)
    {
        var @event = ctx.GetEvent();
        var orderTotal = @event.GetOrderTotal();
        var customerId = @event.GetCustomerId();
        var orderId = ctx.GetEntityId();

        var command = new ReserveCreditCommand(orderTotal, orderId);
        return await ctx.UpdateAsync(typeof(Customer), customerId, command);
    }
}
```

Он обрабатывает событие OrderCreated, пытаясь зарезервировать кредит для клиента, сделавшего заказ.

## **Получаемый результат**

**Источники событий имеют несколько преимуществ:**

* Они решают одну из ключевых проблем в реализации событийно-ориентированной архитектуры и делают возможной надежную публикацию событий при каждом изменении состояния.
* Поскольку сохраняются события, а не доменные объекты, в основном избегается проблема несоответствия импедансов объектно-реляционного отображения.
* Они предоставляют 100% надежный аудиторский журнал изменений, внесенных в бизнес-сущность.
* Они позволяют реализовать временные запросы, определяющие состояние сущности в любой момент времени.
* Бизнес-логика на основе источников событий состоит из слабо связанных бизнес-сущностей, которые обмениваются событиями. Это значительно упрощает переход от монолитного приложения к микросервисной архитектуре.

**Источники событий также имеют несколько недостатков:**

* Это другой и непривычный стиль программирования, поэтому требуется время на обучение.
* Хранилище событий сложно запрашивать, поскольку типичные запросы требуют восстановления состояния бизнес-сущностей. Это, вероятно, будет сложно и неэффективно. В результате приложение должно использовать разделение ответственности при

