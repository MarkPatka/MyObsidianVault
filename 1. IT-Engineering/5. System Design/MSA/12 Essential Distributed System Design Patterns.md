По мере роста и масштабирования систем на множество сервисов команды сталкиваются с такими проблемами, как коммуникация между сервисами, согласованность данных, отказоустойчивость и стратегии развертывания.

Хорошая новость заключается в том, что для многих из этих проблем существуют хорошо зарекомендовавшие себя решения в виде паттернов проектирования. Эти паттерны — проверенные подходы, которые архитекторы и инженеры используют для решения типичных проблем в распределенных архитектурах.

Понимание этих паттернов помогает принимать более взвешенные архитектурные решения, избегать распространенных ошибок и создавать устойчивые, масштабируемые и удобные в поддержке системы.

В этой статье мы рассмотрим 12 паттернов проектирования распределенных систем, которые должен знать каждый архитектор:

- [[API Gateway]]
- [[Point To Point Async Integration]]
- [[Publish/Subscribe Pattern]]
- [[Transactional Outbox Pattern]]
- [[CQRS]]
- [[SAGA]]
- [[Sidecar Pattern]]
- [[Strangler Pattern]]
- [[Anti-Corruption Layer Pattern]]
- [[Service Discovery]]
- [[Sharding Pattern]]
- [[Replication Pattern]]

## API Gateway

API Gateway — это единая точка входа, расположенная между клиентами и вашими внутренними сервисами. Он действует как обратный прокси, который маршрутизирует запросы к соответствующим микросервисам. Часто он также обрабатывает сквозные задачи, такие как аутентификация, ограничение частоты запросов (rate limiting) и трансформация запросов.

![[apigateway_3.png]]

### **Как это работает:**

- Клиент отправляет все запросы к единой конечной точке API Gateway вместо прямых вызовов к отдельным сервисам.
- API Gateway принимает входящий запрос и выполняет проверки аутентификации и авторизации.
- Он применяет правила ограничения частоты запросов для защиты внутренних сервисов от перегрузки.
- Шлюз маршрутизирует запрос к соответствующему микросервису на основе пути URL или заголовков запроса.
- Он может агрегировать ответы от нескольких сервисов в единый ответ для клиента.

### **Преимущества:**

- Упрощает клиентскую реализацию, предоставляя единую конечную точку вместо управления несколькими конечными точками сервисов.
- Предоставляет уровень абстракции, который позволяет внутренним сервисам меняться, не затрагивая клиентов.
- Повышает безопасность, скрывая внутреннюю структуру и конечные точки сервисов от внешних клиентов.

### **Недостатки:**

- Создает единую точку отказа, которая при неправильном проектировании может привести к падению всей системы.
- Может стать узким местом в производительности при обработке высоких объемов трафика.
- Добавляет задержку к каждому запросу из-за дополнительных сетевых переходов.

### **Сценарии использования:**

- Архитектуры микросервисов, где несколько сервисов необходимо предоставлять через единый интерфейс.
- Системы, требующие единообразной аутентификации и авторизации для нескольких сервисов.
- Модернизация legacy-систем, когда нужно скрыть устаревшие сервисы за современным API.

## 2. Point To Point Async Integration

Point To Point Async Integration — это паттерн коммуникации, при котором один сервис отправляет сообщения другому сервису через очередь сообщений.

В отличие от синхронных вызовов, отправитель не ждет немедленного ответа и продолжает обработку, в то время как получатель потребляет сообщения из своей очереди в своем собственном темпе.

Это создает асинхронное, но все же прямое взаимодействие между двумя сервисами.

![[point_to_point_async_integration.png]]

### **Как это работает:**

- Сервис A отправляет сообщение в выделенную очередь, которую потребляет только Сервис B.
- Очередь сообщений действует как буфер между отправителем и получателем, сохраняя сообщения до их обработки.
- Сервис A продолжает обработку сразу после отправки сообщения, не дожидаясь ответа.
- Сервис B обрабатывает сообщения из своей очереди независимо в своем собственном темпе.
- Брокер сообщений гарантирует доставку сообщений и может сохранять их для надежности.
- Если Сервис B временно недоступен, сообщения накапливаются в очереди до его восстановления.
- Очереди недоставленных сообщений (dead letter queues) могут обрабатывать сообщения, которые не удалось обработать после нескольких попыток повтора.

### **Преимущества:**

- Развязывает сервисы во времени, позволяя отправителю и получателю работать с разной скоростью.
- Повышает устойчивость, так как временные сбои в получателе не влияют на отправителя.
- Обеспечивает естественное сглаживание нагрузки, поскольку очередь буферизирует сообщения во время пиков трафика.
- Позволяет асинхронно обрабатывать длительные операции без блокировки отправителя.
- Упрощает независимое масштабирование получателя за счет добавления большего количества экземпляров потребителей.

### **Недостатки:**

- Добавляет зависимость от брокера сообщений, которым нужно управлять и который может стать единой точкой отказа.
- Нарушает согласованность (eventual consistency), так как отправитель не знает, когда и было ли сообщение успешно обработано.
- Усложняет отладку, поскольку поток сообщений является асинхронным и непрямым.

### **Сценарии использования:**

- Обработка фоновых задач, где немедленные ответы не требуются.
- Системы обработки заказов, где заказы ставятся в очередь для сервисов исполнения.
- Сервисы электронной почты или уведомлений, обрабатывающие запросы асинхронно.
- Системы с неравномерной нагрузкой, где очереди обеспечивают буферизацию.

## 3. Publish/Subscribe Pattern

Паттерн Publish/Subscribe — это асинхронный паттерн обмена сообщениями, при котором издатели отправляют сообщения в центральный брокер сообщений или шину событий, не зная, кто их получит.

Подписчики регистрируют свой интерес к определенным типам сообщений и получают их автоматически при публикации, создавая слабо связанную событийно-ориентированную архитектуру.

Вот основное различие между Publish/Subscribe и паттерном Point To Point Async Integration:

- Publish/Subscribe предполагает, что для одного типа события может быть несколько подписчиков.
- Point To Point Async Integration предполагает, что для каждого типа события есть только один подписчик.

![[publish_subscribe_pattern_1.png]]

### **Как это работает:**

- Издатели отправляют сообщения или события в топики или каналы на брокере сообщений, ничего не зная о подписчиках.
- Брокер сообщений принимает и сохраняет сообщения, управляя их распределением между несколькими подписчиками.
- Подписчики регистрируют в конкретных топиках или типах событий, которые хотят получать.
- Когда сообщение публикуется, брокер автоматически доставляет копии всем активным подписчикам.
- Несколько подписчиков могут получать одно и то же сообщение независимо, каждый обрабатывая его согласно своим потребностям.
- Паттерн поддерживает связь «один ко многим», когда одно событие запускает несколько действий.
- Подписчиков можно добавлять или удалять без необходимости изменять издателя.
- Можно применять фильтрацию сообщений, чтобы подписчики получали только сообщения, соответствующие определенным критериям.

### **Преимущества:**

- Развязывает издателей и подписчиков, позволяя независимую разработку и развертывание сервисов.
- Позволяет масштабироваться, давая возможность нескольким подписчикам обрабатывать сообщения параллельно.
- Поддерживает событийно-ориентированные архитектуры, где сервисы реагируют на изменения, а не опрашивают обновления.
- Упрощает добавление нового функционала за счет введения новых подписчиков без изменения существующего кода.
- Повышает устойчивость системы, так как сбои в одном подписчике не влияют на издателей или других подписчиков.

### **Недостатки:**

- Добавляет зависимость от брокера сообщений, которым нужно управлять и который может стать единой точкой отказа.
- Усложняет отладку и трассировку, поскольку поток сообщений асинхронный и непрямой.
- Может привести к проблемам с согласованностью, так как разные подписчики обрабатывают сообщения в разное время.
- Требует тщательного проектирования, чтобы избежать проблем с порядком сообщений и обработкой дубликатов.

### **Сценарии использования:**

- Событийно-ориентированные архитектуры, где несколько сервисов должны реагировать на одни и те же бизнес-события.
- Системы, требующие уведомлений в реальном времени для нескольких потребителей, такие как чат-приложения или дашборды.
- Микросервисы, которым необходимо поддерживать согласованность данных через интеграционные события.
- Сценарии интеграции, когда новые сервисы должны потреблять существующие события без изменения издателей.
- Рабочие процессы, включающие несколько шагов, выполняемых разными сервисами, запускаемые одним событием.

## 4. Outbox Pattern

Паттерн Outbox обеспечивает надежную публикацию событий, сохраняя их в таблице базы данных (outbox) в рамках той же транзакции, что и изменения бизнес-данных.

Отдельный процесс читает из outbox и публикует события в брокер сообщений, гарантируя, что события будут опубликованы тогда и только тогда, когда бизнес-транзакция успешно завершена.

![[transactional_outbox_4.png]]

### **Как это работает:**

- Когда сервис изменяет бизнес-данные, он также вставляет записи о событиях в таблицу outbox в рамках той же транзакции базы данных.
- Транзакция базы данных гарантирует атомарность между изменениями бизнес-данных и созданием событий.
- Отдельный фоновый процесс или воркер постоянно опрашивает таблицу outbox на предмет неопубликованных событий.
- Фоновый процесс читает события из outbox и публикует их в брокер сообщений.
- После успешной публикации событие помечается как обработанное или удаляется из таблицы outbox.
- Если публикация не удалась, событие остается в outbox и будет повторено автоматически.
- Паттерн устраняет проблему двойной записи (dual-write), когда данные сохраняются, но события не публикуются.
- Гарантируется публикация событий как минимум один раз, хотя подписчики должны обрабатывать потенциальные дубликаты.

### **Преимущества:**

- Гарантирует, что события будут опубликованы при успешном выполнении бизнес-транзакции, предотвращая несогласованность данных.
- Устраняет проблему двойной записи, когда фиксация в базе данных успешна, но публикация сообщения терпит неудачу.
- Предоставляет надежный аудиторский след всех событий в системе, хранящихся в базе данных.
- Позволяет воспроизводить и восстанавливать события, сохраняя историю опубликованных событий.

### **Недостатки:**

- Нарушает согласованность, так как события публикуются не сразу, а после опроса.
- Требует дополнительной инфраструктуры для процессора outbox и мониторинга.
- Может создавать дополнительные накладные расходы на производительность из-за дополнительных операций записи в БД и опроса.
- Требует аккуратной обработки дублирующих событий на стороне потребителя из-за доставки "at least one" (для избежания этого можно использовать паттерн InBox с проверками идемпотентности).

### **Сценарии использования:**

- Микросервисы, которым необходимо гарантировать публикацию событий после изменений данных.
- Системы, реализующие событийное проектирование (event sourcing), где каждое изменение состояния должно фиксироваться как событие.
- Любой сценарий, где согласованность данных между сервисами критически важна, а потеря сообщений недопустима.

### 5. CQRS (Command Query Responsibility Segregation)

CQRS — это паттерн, который разделяет операции чтения (запросы) и операции записи (команды), используя разные модели для каждой из них. Модель записи обрабатывает бизнес-логику и изменения данных, в то время как модель чтения оптимизирована для запросов и отчетов.

![[cqrs_1.png]]

### **Как это работает:**

- Команды представляют действия, изменяющие состояние системы, и обрабатываются через модель записи.
- Write model (БД для записи) применяет бизнес-правила, проверяет данные и сохраняет изменения в базу данных.
- Запросы извлекают данные через модель чтения без изменения какого-либо состояния.
- Read model (БД для чтения из нее) часто представляет собой отдельную базу данных или структуру данных, оптимизированную для производительности запросов.
- Изменения, внесенные через модель записи, асинхронно передаются в модель чтения, часто через события.

### **Преимущества:**

- Позволяет независимо оптимизировать модели чтения и записи под их конкретные требования к производительности.
- Позволяет масштабировать операции чтения и записи отдельно в зависимости от фактических паттернов использования.
- Упрощает сложные доменные модели, разделяя логику проверки команд и логику запросов.

### **Недостатки:**

- Нарушает согласованность между моделями записи и чтения.
- Увеличивает сложность системы из-за нескольких моделей и механизмов синхронизации.
- Требует дополнительной инфраструктуры для поддержания синхронизации моделей чтения и записи.

### **Сценарии использования:**

- Приложения со значительно различающейся нагрузкой на чтение и запись, требуют независимого масштабирования.
- Сложные домены, где бизнес-логика для записи сильно отличается от требований к отчетности.
- Системы с высоким соотношением операций чтения к записи, где производительность запросов критически важна.

### 6. Saga Pattern

Паттерн Saga управляет распределенными транзакциями между несколькими сервисами, разбивая их на последовательность локальных транзакций. Каждая локальная транзакция обновляет данные в рамках одного сервиса и публикует событие или сообщение для запуска следующего шага.

Если какой-либо шаг завершается неудачей, выполняются компенсирующие транзакции для отмены изменений, сделанных на предыдущих шагах, поддерживая согласованность данных между сервисами.

![[saga_pattern_1.png]]

### **Как это работает:**

- Saga инициируется, когда бизнес-процесс требует изменений в нескольких сервисах.
- Координатор саги разбивает распределенную транзакцию на последовательность локальных транзакций, по одной на сервис.
- Каждый сервис выполняет свою локальную транзакцию и публикует событие, указывающее на успех или неудачу.
- Координатор слушает эти события и запускает следующий шаг в последовательности.
- Если все шаги завершены успешно, сага завершается, и распределенная транзакция считается завершенной.
- Если какой-либо шаг завершается неудачей, координатор выполняет компенсирующие транзакции в обратном порядке для отмены предыдущих изменений.
- Существует два подхода к реализации: хореография (сервисы координируются через события) и оркестрация (центральный координатор управляет потоком).

### **Преимущества:**

- Позволяет выполнять распределенные транзакции в микросервисах без необходимости распределенных блокировок или двухфазных коммитов.
- Поддерживает согласованность данных через компенсирующие транзакции вместо откатов (rollbacks).
- Позволяет долгоиграющим бизнес-процессам охватывать несколько сервисов с лучшей отказоустойчивостью.
- Хорошо масштабируется, так как каждый сервис управляет своими локальными транзакциями независимо.

### **Недостатки:**

- Вводит сложность в проектирование и реализацию компенсирующих транзакций для каждого шага.
- Нарушает согласованность, что может приводить к временно несогласованным состояниям, видимым пользователям.
- Усложняет отладку и мониторинг, поскольку транзакции охватывают несколько сервисов во времени.
- Может приводить к сложным сценариям обработки ошибок, когда сами компенсирующие транзакции завершаются неудачей.

### **Сценарии использования:**

- Многошаговые рабочие процессы в корпоративных системах, где каждый шаг обрабатывается разным сервисом.
- Любой бизнес-процесс, требующий скоординированных изменений в нескольких микросервисах без распределенных блокировок.

### 7. Sidecar Pattern

Паттерн Sidecar развертывает вспомогательный компонент вместе с основным контейнером приложения, который предоставляет дополнительные функции, такие как логирование, мониторинг, конфигурация или сетевые возможности.

Sidecar работает в той же среде выполнения, что и основное приложение, и имеет тот же жизненный цикл, что позволяет расширять функциональность без изменения кода приложения.

![[sidecar_pattern_1.png]]

### **Как это работает:**

- Контейнер Sidecar развертывается вместе с основным контейнером приложения в том же контейнере или на том же хосте.
- Оба контейнера используют одно сетевое пространство имен, позволяя общаться через localhost.
- Sidecar может перехватывать входящий и исходящий трафик и обрабатывать сквозные задачи, такие как логирование, сбор метрик или функциональность service mesh.
- Общение между приложением и Sidecar происходит через локальные сетевые вызовы.
- Обновления функциональности Sidecar можно развертывать независимо без изменения приложения.
- К одному приложению можно подключить несколько Sidecar для разных целей.

### **Преимущества:**

- Отделяет инфраструктурные задачи от кода приложения, сохраняя код сфокусированным на бизнес-логике.
- Позволяет создавать полиглотные архитектуры, так как Sidecar работают с любым языком или фреймворком приложения.
- Упрощает разработку приложений, предоставляя повторно используемые инфраструктурные компоненты.
- Позволяет независимо обновлять инфраструктурные функции без переразвертывания приложений.
- Уменьшает дублирование кода между сервисами, централизуя общую функциональность в Sidecar.

### **Недостатки:**

- Увеличивает потребление ресурсов, так как каждый экземпляр приложения запускает дополнительные контейнеры Sidecar.
- Добавляет сложности в конфигурацию развертывания и оркестрации.
- Может вносить задержку из-за дополнительных сетевых переходов между приложением и сайдкаром.

### **Сценарии использования:**

- Реализации service mesh, предоставляющие управление трафиком, безопасность и наблюдаемость.
- Централизованное логирование, где сайдкары собирают и пересылают логи приложения в системы логирования.
- Управление конфигурацией, где сайдкары динамически получают и обновляют конфигурацию.
- Событийно-ориентированная интеграция, где сайдкар обрабатывает обмен сообщениями через подключаемые реализации очередей (например, Kafka, RabbitMQ, Azure Service Bus), позволяя бесшовно переключаться между ними без изменения основного приложения (например, с использованием Dapr).

### 8. Strangler Pattern

Паттерн Strangler  — это стратегия постепенной миграции, которая заменяет legacy-систему путем поэтапного построения новой системы вокруг нее.

Этот паттерн направляет новый функционал в новую систему, в то время как legacy-система продолжает обрабатывать существующие функции до тех пор, пока не будет полностью заменена и сможет быть выведена из эксплуатации.

![[strangler_pattern_1.png]]

### **Как это работает:**

- Фасад или слой маршрутизации размещается перед legacy-системой, чтобы перехватывать все входящие запросы.
- Новые функции реализуются в новой системе вместо старой кодовой базы.
- Слой маршрутизации направляет запросы либо в legacy-систему, либо в новую систему в зависимости от функции.
- Существующий функционал постепенно переносится из legacy-системы в новую небольшими порциями.
- Обе системы работают параллельно в период миграции, при этом legacy-система со временем обрабатывает все меньше функций.

### **Преимущества:**

- Снижает риски, позволяя проводить постепенную миграцию вместо рискованного "big-bang" переписывания.
- Позволяет непрерывно поставлять ценность, так как новые функции могут выпускаться во время миграции.
- Минимизирует сбои для пользователей, поскольку система остается работоспособной на протяжении всей миграции.

### **Недостатки:**

- Увеличивает операционную сложность из-за необходимости одновременного обслуживания двух систем.
- Требует дополнительной инфраструктуры для маршрутизации, синхронизации и обеспечения согласованности данных.
- Усложняет тестирование, так как обе системы необходимо проверять во время переходного периода.

### **Сценарии использования:**

- Модернизация устаревших монолитных приложений путем миграции на архитектуру микросервисов.
- Замена устаревших технологических стеков современными фреймворками и языками.
- Постепенное перемещение on-premises систем в облачные решения.
- Рефакторинг систем с низким качеством кода или техническим долгом.
- Любая крупномасштабная замена системы, где простои и риски должны быть минимизированы.

### 9. Anti-Corruption Layer Pattern

Паттерн Anti-Corruption Layer создает защитную границу между вашей доменной моделью и внешними системами или legacy-кодом.

Этот слой выполняет преобразование между различными моделями, предотвращая проникновение внешних концепций и структур в ваш доменный дизайн и позволяя вашей системе развиваться независимо.

![[anti-corruption_layer_pattern_1.png]]
###  **Как это работает:**

- Антикоррупционный слой находится между вашей доменной моделью и внешними системами или legacy-сервисами.
- Слой действует как переводчик, преобразуя внешние структуры данных и концепции в язык вашего домена.
- Когда вашей системе нужны данные из внешних источников, слой получает их и преобразует.
- Ваш доменный код взаимодействует только с антикоррупционным слоем, никогда напрямую с внешними системами.
- Слой защищает ваш домен от изменений во внешних системах, абсорбируя сложность интеграции.
- Он может агрегировать несколько внешних вызовов в единые доменные операции.

### **Преимущества:**

- Защищает вашу доменную модель от внешних изменений, сохраняя ее чистой и сфокусированной на бизнес-логике.
- Позволяет вашей системе развиваться независимо, не будучи ограниченной дизайном внешних систем.
- Упрощает тестирование, предоставляя четкую границу для мокирования внешних зависимостей.
- Упрощает замену внешних систем, так как логика интеграции централизована в одном слое.

### **Недостатки:**

- Добавляет усилия на разработку, поскольку необходимо писать и поддерживать логику преобразования.
- Вводит дополнительный слой, который может влиять на производительность из-за накладных расходов на преобразование данных.
- Требует тщательного проектирования, чтобы сам слой не стал узким местом или чрезмерно сложным.

### **Сценарии использования:**

- Интеграция со сторонними API, имеющими разные доменные модели или терминологию.
- Защита микросервисов от сложностей legacy-систем во время постепенной модернизации.
- Работа с внешними системами, имеющими плохие модели данных или неконсистентные интерфейсы.
- Построение систем, которые должны оставаться стабильными, несмотря на частые изменения во внешних зависимостях.

### 10. Service Discovery Pattern

Паттерн Service Discovery позволяет сервисам находить и общаться друг с другом динамически без жесткого кодирования сетевых расположений.

По мере масштабирования, перемещения между хостами или замены сервисов, реестр сервисов поддерживает актуальную карту доступных экземпляров сервисов и их сетевых адресов, позволяя клиентам автоматически находить сервисы.

![[service_discovery_registry_5.png]]

### **Как это работает:**

- Центральный реестр сервисов ведет каталог всех доступных экземпляров сервисов и их сетевых расположений.
- Когда сервис запускается, он регистрирует себя в реестре сервисов, предоставляя свой адрес и метаданные.
- Сервис отправляет периодические "heartbeat"-сигналы в реестр, чтобы показать, что он все еще работоспособен и доступен.
- Если сервис перестает отправлять "heartbeat"-сигналы, реестр автоматически удаляет его из списка доступных экземпляров.
- Когда клиенту необходимо вызвать сервис, он запрашивает реестр, чтобы получить текущие адреса доступных экземпляров.
- Клиент получает список работоспособных экземпляров сервиса и выбирает один на основе стратегий балансировки нагрузки.
- Существует два основных подхода: обнаружение на стороне клиента (клиенты запрашивают реестр) и обнаружение на стороне сервера (балансировщик нагрузки запрашивает реестр).
- Реестр может быть распределен между несколькими узлами для высокой доступности и отказоустойчивости.
- Популярные реализации включают Consul, Eureka, DNS-сервис обнаружения в Kubernetes.

### **Преимущества:**

- Позволяет динамическое масштабирование, так как сервисы можно добавлять или удалять без изменения конфигураций.
- Повышает устойчивость, автоматически направляя трафик от неработоспособных экземпляров.
- Упрощает развертывание, так как сервисам не нужно знать точное расположение их зависимостей.
- Поддерживает различные окружения и регионы, где адреса сервисов различаются.

### **Недостатки:**

- Вводит реестр сервисов как критическую зависимость, которая должна быть высокодоступной.
- Добавляет сетевую задержку из-за запросов к реестру перед вызовами сервисов.
- Увеличивает сложность общей архитектуры системы и развертывания.

### **Сценарии использования:**

- Архитектуры микросервисов с динамическим масштабированием, где экземпляры сервисов часто меняются.
- Cloud-native приложения, развернутые в нескольких зонах доступности или регионах.
- Платформы оркестрации контейнеров, такие как Kubernetes, управляющие сотнями экземпляров сервисов.
- Системы, требующие автоматического переключения при отказе (failover) при неработоспособности экземпляров сервисов.

### 11. Sharding Pattern

Паттерн Sharding делит данные горизонтально между несколькими базами данных или узлами хранения, причем каждый шард содержит подмножество общих данных.

Данные распределяются на основе ключа шардирования, что позволяет системе масштабировать емкость хранения и обработки путем добавления большего количества шардов по мере роста объема данных.

![[sharding_1.png]]

### **Как это работает:**

- Данные разделяются горизонтально на основе ключа шардирования, такого как ID пользователя, географический регион или хэш-значение.
- Каждый шард представляет собой отдельный экземпляр базы данных, который хранит только часть общего набора данных.
- Слой маршрутизации или логика приложения определяет, какой шард содержит запрашиваемые данные.
- Ключ шардирования используется для вычисления того, какой шард должен обрабатывать каждую операцию чтения или записи.
- Запросы, обращающиеся к одному шарду, выполняются быстро, избегая операций между шардами.
- Запросы между шардами требуют координации между несколькими шардами, что сложнее и медленнее.
- Новые шарды можно добавлять для распределения нагрузки по мере роста объема данных.
- Каждый шард можно масштабировать независимо на основе его конкретных характеристик нагрузки.
- Паттерн работает лучше всего, когда паттерны доступа к данным соответствуют стратегии шардирования.

### **Преимущества:**

- Позволяет горизонтально масштабировать хранение данных за пределы возможностей одной базы данных.
- Улучшает производительность запросов за счет уменьшения размера набора данных, который должна обрабатывать каждая база.
- Позволяет независимо масштабировать "горячие" шарды, получающие больше трафика.
- Повышает доступность, так как сбои затрагивают только подмножество данных, а не всю систему.

### **Недостатки:**

- Вносит сложность в определение оптимального ключа и стратегии шардирования.
- Затрудняет, замедляет, а иногда делает невозможными запросы и транзакции между шардами.
- Усложняет изменение схемы базы данных, которое должно применяться ко всем шардам.
- Требует тщательного планирования, чтобы избежать неравномерного распределения данных, создающего "горячие точки" (hot spots).

### **Сценарии использования:**

- Крупномасштабные приложения с объемами данных, превышающими возможности одной базы данных.
- Мультитенантные SaaS-платформы, где данные можно шардировать по ID арендатора.
- Платформы социальных медиа, шардирующие данные пользователей по географическому региону или ID пользователя.
- Электронные коммерческие системы, разделяющие каталоги продуктов и заказы по категориям или продавцам.

### 12. Replication Pattern

Паттерн Replication создает несколько копий данных на разных узлах или в базах данных для повышения доступности, отказоустойчивости и производительности чтения.

Изменения данных распространяются с первичного узла на узлы-реплики, обеспечивая синхронизацию нескольких копий и возможность продолжения работы системы даже при сбоях некоторых узлов.

![[replication_1.png]]

### **Как это работает:**

- Первичный узел (primary) получает все операции записи и служит авторитетным источником данных.
- Изменения, внесенные в первичный узел, автоматически реплицируются на один или несколько узлов-реплик.
- Репликация может быть синхронной (когда запись ждет подтверждения от реплики) или асинхронной для лучшей производительности.
- Узлы-реплики могут обслуживать запросы на чтение, распределяя нагрузку запросов между несколькими узлами.
- При сбое первичного узла одна из реплик может быть повышена до статуса нового первичного узла.
- Существуют разные топологии репликации: первичный-реплика, мульти-первичный (multi-primary) и одноранговая (peer-to-peer) репликация.
- Паттерн часто комбинируется с шардированием, где каждый шард имеет свою собственную настройку репликации.

### **Преимущества:**

- Улучшает производительность чтения за счет распределения запросов между несколькими узлами-репликами.
- Повышает доступность, так как система продолжает работать при сбое первичного узла.
- Предоставляет возможности аварийного восстановления с географически распределенными репликами.
- Позволяет проводить обслуживание без простоя, переводя реплики в офлайн без влияния на сервис.
- Защищает от потери данных за счет наличия нескольких копий критически важных данных.

### **Недостатки:**

- Нарушает согласованность, когда реплики могут временно иметь устаревшие данные.
- Увеличивает стоимость хранения из-за дублирования данных на нескольких узлах.
- Добавляет сложности в обработку переключения при отказе и обеспечение правильной синхронизации реплик.
- Может создавать конфликты в настройках с несколькими первичными узлами, требующие сложной логики разрешения.

### **Сценарии использования:**

- Высокодоступные системы, требующие непрерывной работы несмотря на аппаратные сбои.
- Глобальные приложения, обслуживающие пользователей из нескольких географических регионов с низкой задержкой.
- Нагрузки с преобладанием операций чтения, где распределение запросов улучшает общую производительность системы.
- Сценарии аварийного восстановления, требующие копий данных в разных дата-центрах.
- Системы, требующие восстановления на определенный момент времени (point-in-time recovery) или резервных реплик для защиты данных.

### Резюме

Паттерны проектирования распределенных систем предоставляют проверенные решения общих архитектурных проблем, но каждый из них предполагает важные компромиссы.

Например:
- API Gateway упрощает коммуникацию с клиентами, но вводит потенциальное узкое место.
- Событийно-ориентированные паттерны, такие как Publish/Subscribe и Outbox, обеспечивают слабую связанность, но создают согласованность в конечном счете.
- CQRS и Sharding улучшают производительность ценой увеличения сложности.

Понимание этих компромиссов и знание того, когда применять каждый паттерн, — это ключевой навык каждого архитектора.

Правильное архитектурное решение зависит от вашего конкретного контекста, ограничений и от того, можете ли вы принять компромиссы, связанные с каждым паттерном.