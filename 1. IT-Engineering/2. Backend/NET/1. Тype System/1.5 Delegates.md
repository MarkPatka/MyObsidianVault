### Делегаты

Делегаты — это ссылочные типы, аналогичные по назначению указателям на функции в языке C++. Они применяются в обработчиках событий и функциях обратного вызова в составе платформы .NET. В отличие от указателей функций, делегаты являются безопасными, проверяемыми и типобезопасными. Тип делегата может представлять любой метод экземпляра или статический метод, имеющий совместимую сигнатуру.

Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.

Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.

Делегат называют связанным с методом, который он представляет. Помимо привязки к методу, делегат может быть связан с отдельным объектом. Этот объект представляет первый параметр метода и передается методу при каждом вызове делегата. Если это метод экземпляра, то связанный объект передается как неявный параметр `this`; если метод является статическим, то объект передается как первый формальный параметр метода, и сигнатура делегата при этом должна соответствовать остальным параметрам.

Среда CLR предоставляет каждый тип делегата с `BeginInvoke` и методами `EndInvoke`, чтобы включить асинхронный вызов делегата. 

Объявление типа делегата устанавливает контракт, указывающий подпись одного или нескольких методов. Делегат — это экземпляр типа делегата, на который ссылается:

- Метод экземпляра типа и целевого объекта, назначаемого данному типу.

- Метод экземпляра типа с скрытым параметром `this`, предоставляемым в списке формальных параметров. Делегат считается делегатом открытого экземпляра.

- Статический метод.

- Статический метод и целевой объект, назначаемый первому параметру метода. Делегат, как утверждается, закрыт по поводу своего первого аргумента.

Когда делегат представляет метод экземпляра, закрытый по его первому аргументу (наиболее распространенному варианту), делегат сохраняет ссылку на точку входа метода и ссылку на объект, называемый целевым объектом, который является типом, который можно назначить типу, определяемому методом. Когда делегат представляет открытый метод экземпляра, он сохраняет ссылку на точку входа метода. Подпись делегата должна включать скрытый параметр `this` в его формальный список параметров; В этом случае делегат не имеет ссылки на целевой объект, а целевой объект должен быть предоставлен при вызове делегата.

Когда делегат представляет статический метод, делегат сохраняет ссылку на точку входа метода. Когда делегат представляет статический метод, закрытый по его первому аргументу, делегат сохраняет ссылку на точку входа метода и ссылку на целевой объект, назначаемый типу первого аргумента метода. При вызове делегата первый аргумент статического метода получает целевой объект. Этот первый аргумент должен быть ссылочным типом.

Список вызовов делегата — это упорядоченный набор делегатов, в которых каждый элемент списка вызывает именно один из методов, представленных делегатом. Список вызовов может содержать повторяющиеся методы. Во время вызова методы вызываются в порядке, в котором они отображаются в списке вызовов. Делегат пытается вызвать каждый метод в списке вызовов; повторяющиеся экземпляры вызываются один раз при каждом отображении в списке вызовов. Делегаты неизменяемы; После создания список вызовов делегата не изменяется.

Делегаты называются многоадресной рассылкой, так как делегат может вызывать один или несколько методов и может использоваться в сочетании операций.

## Базовый пример делегата

```C#
using System;

// Объявление делегата
public delegate void PrintMessage(string message);

class Program
{
    static void Main()
    {
        // Создание экземпляра делегата
        PrintMessage printer = PrintToConsole;
        
        // Вызов делегата
        printer("Hello, World!");
        
        // Добавление методов в делегат
        printer += PrintToConsoleUpper;
        printer("Multiple handlers");
    }
    
    static void PrintToConsole(string message)
    {
        Console.WriteLine($"Message: {message}");
    }
    
    static void PrintToConsoleUpper(string message)
    {
        Console.WriteLine($"Uppercase: {message.ToUpper()}");
    }
}
```

## Делегаты с возвращаемыми значениями

```C#
using System;

// Делегат с возвращаемым значением
public delegate int MathOperation(int a, int b);

class Program
{
    static void Main()
    {
        MathOperation operation = Add;
        Console.WriteLine($"5 + 3 = {operation(5, 3)}");
        
        operation = Multiply;
        Console.WriteLine($"5 * 3 = {operation(5, 3)}");
        
        // Многоадресный делегат
        MathOperation multiOperation = Add;
        multiOperation += Multiply;
        
        // Будет возвращен результат последнего метода
        int result = multiOperation(5, 3);
        Console.WriteLine($"Last result: {result}");
    }
    
    static int Add(int a, int b) => a + b;
    static int Multiply(int a, int b) => a * b;
}
```

## Встроенные делегаты (Action, Func, Predicate)

```C#
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        // Action - для методов без возвращаемого значения
        Action<string> actionExample = (message) => 
            Console.WriteLine($"Action: {message}");
        actionExample("Hello Action!");
        
        // Func - для методов с возвращаемым значением
        Func<int, int, string> funcExample = (a, b) => 
            $"Func result: {a + b}";
        Console.WriteLine(funcExample(10, 20));
        
        // Predicate - для методов, возвращающих bool
        Predicate<int> isEven = (number) => number % 2 == 0;
        Console.WriteLine($"Is 10 even? {isEven(10)}");
        
        // Использование с коллекциями
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
        List<int> evenNumbers = numbers.FindAll(isEven);
        Console.WriteLine("Even numbers: " + string.Join(", ", evenNumbers));
    }
}

```

## Делегаты как параметры методов

```C#
using System;

class Calculator
{
    public delegate double Operation(double a, double b);
    
    public static double Calculate(double a, double b, Operation operation)
    {
        return operation(a, b);
    }
}

class Program
{
    static void Main()
    {
        // Передача метода как параметра
        double result = Calculator.Calculate(10, 5, Add);
        Console.WriteLine($"10 + 5 = {result}");
        
        // Использование лямбда-выражения
        result = Calculator.Calculate(10, 5, (a, b) => a * b);
        Console.WriteLine($"10 * 5 = {result}");
        
        // Более сложная операция
        result = Calculator.Calculate(10, 3, (a, b) => Math.Pow(a, b));
        Console.WriteLine($"10^3 = {result}");
    }
    
    static double Add(double a, double b) => a + b;
}

```

## События с делегатами

```C#
using System;

// Класс, генерирующий события
public class Button
{
    // Объявление события
    public event Action<string> OnClick;
    
    public void Click()
    {
        Console.WriteLine("Button clicked!");
        // Вызов события
        OnClick?.Invoke("Button was clicked!");
    }
}

class Program
{
    static void Main()
    {
        Button button = new Button();
        
        // Подписка на событие
        button.OnClick += (message) => 
            Console.WriteLine($"Event handler 1: {message}");
        
        button.OnClick += (message) => 
            Console.WriteLine($"Event handler 2: Processing {message}");
        
        // Имитация нажатия кнопки
        button.Click();
        
        // Отписка от события
        Action<string> handler = (message) => 
            Console.WriteLine($"This won't be called");
        button.OnClick += handler;
        button.OnClick -= handler;
        
        button.Click();
    }
}

```

