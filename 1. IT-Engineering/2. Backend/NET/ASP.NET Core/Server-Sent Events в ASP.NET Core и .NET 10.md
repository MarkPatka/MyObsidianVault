Время чтения: 5 мин·
20 декабря 2025

**Обновления в реальном времени перестали быть просто "приятной опцией". Большинство современных UI-приложений ожидают от сервера потоков данных в реальном времени. Много лет стандартным решением в экосистеме .NET был SignalR. Хотя SignalR невероятно мощный, для более простых сценариев полезно иметь и другие варианты.**

С выходом ASP.NET Core 10 у нас наконец-то появился нативный API высокого уровня для Server-Sent Events (SSE). Он заполняет пробел между простым HTTP-опросом (polling) и полноценными двусторонними WebSocket'ами через SignalR.
**Почему SSE, а не SignalR?**

SignalR — это мощный инструмент, который автоматически работает с WebSockets, Long Polling и SSE, предоставляя полнодуплексный (двусторонний) канал связи. Однако за это приходится платить: специальный протокол (Hubs), обязательная клиентская библиотека и необходимость в "липких сессиях" (sticky sessions) или бэкплейне (например, Redis) для масштабирования.

## Отличия SSE от SignalR

- **Однонаправленный протокол:** Специально разработан для потоковой передачи данных от сервера клиенту.
  
- **Нативный HTTP:** Это просто стандартный HTTP-запрос с типом контента `text/event-stream`. Никаких кастомных протоколов.
  
- **Автоматическое переподключение:** Браузеры нативно обрабатывают переподключения через API `EventSource`.
  
- **Легковесный:** Не требуются тяжелые клиентские библиотеки или сложная логика подтверждения соединения.

## Эндпоинт для Server-Sent Events

Прелесть нового SSE API в .NET 10 — его простота. Вы можете использовать новый `Results.ServerSentEvents` для возврата потока событий из любого `IAsyncEnumerable<T>`. Поскольку `IAsyncEnumerable` представляет собой поток данных, которые могут поступать с течением времени, сервер понимает, что нужно держать HTTP-соединение открытым, а не закрывать его после первой "порции" данных.

Вот минимальный пример SSE-эндпоинта, который в реальном времени стримит информацию о размещенных заказах:

```csharp
app.MapGet("orders/realtime", (
    ChannelReader<OrderPlacement> channelReader,
    CancellationToken cancellationToken) =>
{
    // 1. ReadAllAsync возвращает IAsyncEnumerable
    // 2. Results.ServerSentEvents говорит браузеру: "Держи это соединение открытым"
    // 3. Новые данные отправляются клиенту, как только попадают в канал
    return Results.ServerSentEvents(
        channelReader.ReadAllAsync(cancellationToken),
        eventType: "orders");
});
```

Когда клиент обращается к этому эндпоинту:

1.  Сервер отправляет заголовок `Content-Type: text/event-stream`.
2.  Соединение остается активным и бездействует в ожидании данных.
3.  Как только ваше приложение помещает заказ в `Channel`, `IAsyncEnumerable` возвращает этот элемент, и .NET немедленно отправляет его по открытому HTTP-каналу в браузер.

Это невероятно эффективный способ обработки "push"-уведомлений без накладных расходов полноценного протокола с отслеживанием состояния.

Здесь я использую `Channel` как средство для достижения цели. В реальном приложении у вас может быть фоновый сервис, который слушает очередь сообщений (например, RabbitMQ или Azure Service Bus) или ленту изменений базы данных и помещает новые события в канал для потребления подключенными клиентами.

## Обработка пропущенных событий

Простой эндпоинт, который мы только что построили, хорош, но у него есть слабое место: ему не хватает устойчивости.

Одна из самых больших проблем с потоками реального времени — это разрывы соединения. К тому времени, когда браузер автоматически переподключится, несколько событий уже могли быть отправлены и потеряны. Чтобы решить эту проблему, в SSE есть встроенный механизм: заголовок `Last-Event-ID`. Когда браузер переподключается, он отправляет этот ID обратно на сервер.

В .NET 10 мы можем использовать тип `SseItem<T>`, чтобы обернуть наши данные метаданными, такими как ID и интервалы повтора.

Комбинируя простой буфер событий в памяти `OrderEventBuffer` с `Last-Event-ID`, предоставляемым браузером, мы можем "воспроизвести" пропущенные сообщения при переподключении:

```csharp
app.MapGet("orders/realtime/with-replays", (
    ChannelReader<OrderPlacement> channelReader,
    OrderEventBuffer eventBuffer,
    [FromHeader(Name = "Last-Event-ID")] string? lastEventId,
    CancellationToken cancellationToken) =>
{
    async IAsyncEnumerable<SseItem<OrderPlacement>> StreamEvents()
    {
        // 1. Воспроизводим пропущенные события из буфера
        if (!string.IsNullOrWhiteSpace(lastEventId))
        {
            var missedEvents = eventBuffer.GetEventsAfter(lastEventId);
            foreach (var missedEvent in missedEvents)
            {
                yield return missedEvent;
            }
        }

        // 2. Потоково отправляем новые события по мере их появления в Channel
        await foreach (var order in channelReader.ReadAllAsync(cancellationToken))
        {
            var sseItem = eventBuffer.Add(order); // Буфер присваивает уникальный ID
            yield return sseItem;
        }
    }

    return TypedResults.ServerSentEvents(StreamEvents(), "orders");
});
```

## Фильтрация Server-Sent Events по пользователю

Server-Sent Events построен поверх стандартного HTTP. Поскольку это стандартный GET-запрос, ваша существующая инфраструктура "просто работает":

*   **Безопасность:** Вы можете передать стандартный JWT в заголовке `Authorization`.
*   **Контекст пользователя:** Вы можете получить доступ к `HttpContext.User`, чтобы извлечь User ID и отфильтровать поток. Вы отправляете пользователю только те данные, которые принадлежат ему.

Вот пример SSE-эндпоинта, который стримит только заказы аутентифицированного пользователя:

```csharp
app.MapGet("orders/realtime", (
    ChannelReader<OrderPlacement> channelReader,
    IUserContext userContext, // Внедренный контекст, содержащий метаданные пользователя
    CancellationToken cancellationToken) =>
{
    // UserId извлечен из JWT access token через IUserContext
    var currentUserId = userContext.UserId;

    async IAsyncEnumerable<OrderPlacement> GetUserOrders()
    {
        await foreach (var order in channelReader.ReadAllAsync(cancellationToken))
        {
            // Мы возвращаем только данные, принадлежащие аутентифицированному пользователю
            if (order.CustomerId == currentUserId)
            {
                yield return order;
            }
        }
    }

    return Results.ServerSentEvents(GetUserOrders(), "orders");
})
.RequireAuthorization(); // Стандартная авторизация ASP.NET Core
```

Обратите внимание, что когда вы пишете сообщение в `Channel`, оно транслируется всем подключенным клиентам. Это не идеально для потоков, специфичных для пользователя. Для продакшена вам, вероятно, понадобится что-то более надежное.

## Итог

SSE в .NET 10 — это идеальная золотая середина для простых однонаправленных обновлений, таких как дашборды, колокольчики уведомлений и индикаторы выполнения. Это легковесное, нативное для HTTP и простое в защите с использованием вашего существующего middleware решение.

Тем не менее, SignalR остается надежным, проверенным в боях выбором для сложной двусторонней коммуникации или для масштабирования, требующего бэкплейна.

Цель не в том, чтобы заменить SignalR, а в том, чтобы дать вам более простой инструмент для более простых задач. Выбирайте самый легкий инструмент, который решает вашу проблему.