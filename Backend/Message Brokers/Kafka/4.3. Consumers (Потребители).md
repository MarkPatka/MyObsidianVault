Партиции в консумер-группах распределяет автоматически **_Group Coordinator_** при помощи **_Group leader_** — первого участника в группе. Каждый консумер в группе может читать одну и более партиций разных топиков. Если консумеру не достанется партиции, то он будет бездействовать, что мешает масштабированию.

Основное преимущество консумер-группы перед обычным консумером состоит в хранении оффсета партиций на стороне брокера. Это позволяет консумерам прерывать работу, а после возобновлять её с того же места, где они окончили чтение.

Для проверки живости консумеры отправляют брокеру **_Heartbeat-сообщение_**. Если консумер не успел отправить его, то может покинуть группу сам, либо брокер, который не получил подтверждение, сам удалит консумера из группы, что запустит ребалансировку.

Любая смена композиции партиций в топиках и участников в группе запускает ребалансировку. Это болезненный процесс для консумеров. В этот момент все консумеры остановят чтение и не начнут его до полной синхронизации и стабилизации группы. Есть различные алгоритмы ребалансировки, которые позволяют смягчить процесс, но по умолчанию это **_Stop-The-World_**.

В новом консумере важно правильно выбрать политику оффсета. Иногда читать с начала не нужно и достаточно «перемотать» оффсет в конец, чтобы сразу получать только новые события.

Наконец, два и более консумеров в группе не могут читать из одной и той же партиции. Чтобы не оказаться в ситуации, когда вам некуда масштабироваться при чтении, заранее установите достаточное число партиций. 

![[kafka-image-consumers.png]]

---
### Дизайн консумера

![[kafka-image-consumer-design.png]]

Типичная программа-консумер работает так: при запуске внутри неё работает таймер, который периодически пyллит новые записи из партиций брокеров. Пyллер получает список батчей, связанных с топиками партициями, из которых читает консумер. Далее полученные сообщения в батчах десериализуются. В итоге консумер, как правило, как-то обрабатывает сообщения.

В конце чтения консумер может закоммитить оффсет — запомнить позицию считанных записей и продолжить чтение новой порции данных. Читать можно как синхронно, так и асинхронно. Оффсет можно коммитить или не коммитить вовсе. Commit также может быть: 
*Auto commit* (at most once (miss messages)) и *Manual commit* (at least once (duplicate messages)) или использовать для *Custom offset management* для реализации *exacltly once* семантики доставки.

Таким образом, если консумер прочитал сообщение из партиции, обработал его, а затем аварийно завершился, не закоммитив оффсет, то следующий подключенный консумер при следующем подключении вновь прочитает ту же порцию данных.

Главное — консумер периодически вычитывает новую порцию данных, десериализует их и следом обрабатывает.
