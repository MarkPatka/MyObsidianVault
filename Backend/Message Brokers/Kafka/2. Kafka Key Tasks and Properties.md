## Свойства Kafka

**Распределённость**: множество серверов работают слаженно
- Kafka изначально проектировалась как распределённая система (кластер). Она не работает на одном сервере, а состоит из множества машин (брокеров), которые объединены в кластер и координируют свои действия.
- Данные (topics) разделяются на партиции и распределяются по разным брокерам в кластере. Каждая партиция реплицируется на несколько брокеров для обеспечения отказоустойчивости. Один из брокеров (контроллер) координирует работу кластера (назначение лидеров для партиций, мониторинг состояния узлов).
- Распределённость — это фундамент для всех остальных свойств: масштабируемости, отказоустойчивости и высокой производительности.

**Отказоустойчивость**: выход одного узла не нарушает доступ к данным.
- Система продолжает работать без потери данных и с минимальными перерывами в обслуживании, даже если один или несколько серверов выходят из строя.
- Достигается за счет **репликации**. Для каждой партиции создается несколько реплик, которые хранятся на разных физических серверах. Одна реплика является лидером (leader) и обрабатывает все запросы на чтение и запись. Остальные — followers (ведомые) — синхронно или асинхронно копируют данные с лидера. Если брокер с лидер-репликой падает, одна из follower-реплик автоматически и мгновенно становится новым лидером.
- Обеспечивает высокую доступность и надежность системы, что критически важно для бизнес-критичных приложений.

**Согласованность данных**: поддержка CAP-теоремы.
- [[CAP theorem]] гласит, что распределённая система не может одновременно обеспечить все три свойства: 
  - **Consistency** (согласованность), 
  - **Availability** (доступность), 
  - **Partition tolerance** (устойчивость к разделению).

Kafka жертвует мгновенной согласованностью в угоду доступности и устойчивости к сетевым сбоям.
- Kafka настраиваема и позволяет выбрать приоритет. По умолчанию она обеспечивает **eventual consistency**: все реплики рано или поздно придут к исходному состоянию. Однако можно настроить producers на ожидание подтверждения записи от всех синхронных реплик (acks=all). В этом случае мы получаем **strong consistency** (строгую согласованность), но жертвуем latency (задержкой), так как запись будет завершена только после подтверждения от всех реплик.
- Дает архитекторам гибкость в выборе баланса между надежностью доставки, задержкой и согласованностью в зависимости от требований конкретного use case.

**Высокая производительность**: обработка миллионов сообщений в секунду. Достигается за счет нескольких ключевых принципов:
1. **Sequential I/O (Последовательный ввод/вывод):** Kafka записывает данные на диск последовательно (дописывая в конец файла-лога), что кардинально быстрее произвольного доступа (random I/O) в базах данных.
2. **Zero-Copy:** Минимизирует копирование данных внутри ядра ОС при их отправке от диска к сетевой карте.
3. **Пакетная обработка (Batching):** Данные группируются в batches перед отправкой по сети или записью на диск, что снижает накладные расходы.
4. **Сжатие данных:** Сообщения в батчах эффективно сжимаются (murmur2), экономя пропускную способность сети и место на диске.

**Горизонтальное масштабирование**: лёгкость добавления и удаления узлов.
- Чтобы увеличить мощность кластера, нужно просто добавить новые серверы (брокеры).
- Данные в Kafka уже распределены по партициям. При добавлении нового брокера Kafka автоматически может перераспределить часть партиций на него, чтобы сбалансировать нагрузку. Процесс масштабирования не требует остановки кластера.
- Позволяет легко и практически линейно наращивать пропускную способность и объем хранилища системы по мере роста бизнес-потребностей.

**Интегрируемость с различными системами.**
- Kafka легко соединяется с сотнями внешних систем для приема данных (источники, sources) и для отправки данных (стоки, sinks).
- Kafka включает **[[4.8. Kafka Connect]]** (фреймворк для создания и управления коннекторами к таким системам, как базы данных, Hadoop, S3, Elasticsearch и др.) и **[[4.9. Kafka Streams]]** (библиотека для потоковой обработки данных прямо внутри приложения). Также существует огромное количество клиентских библиотек для разных языков программирования (Java, Python, Go, .NET и т.д.).
- Kafka выступает в роли **центральной нервной системы** данных компании, унифицируя и интегрируя разнородные источники и потребители данных.

### Задачи Kafka

**Обработка разнородных событий.**

- Современные системы генерируют огромное количество событий (events) разного формата и назначения: клики пользователей, логи приложений, телеметрия с IoT-устройств, финансовые транзакции, изменения в базах данных.

- Она предоставляет единую, стандартизированную и высокопроизводительную платформу для приема, хранения и распространения этих событий. Вместо того чтобы создавать множество точечных интеграций между системами, все приложения просто подключаются к Kafka и публикуют или потребляют события нужного формата из соответствующих топиков.

**Проблемы надёжности и гарантии доставки данных.**

В распределённых системах сети ненадежны, серверы падают. При прямом взаимодействии между сервисами (point-to-point) сообщение может быть потеряно, если потребитель недоступен.

- **Буферизация и хранение:** Kafka действует как надежный буфер. Producer отправляет сообщение в Kafka, и оно гарантированно сохраняется на диск (в соответствии с настройками `acks`). Consumer читает его тогда, когда сможет. Потребитель и производитель работают асинхронно и не зависят от доступности друг друга.

- **Гарантии доставки:** Настройки `acks` позволяют гарантировать, что сообщение будет записано в N реплик, прежде чем producer получит подтверждение. Позиция чтения (offset) каждого consumer сохраняется в Kafka. Это позволяет consumer в случае сбоя перезапуститься и продолжить чтение именно с того места, где он остановился, не потеряв ни одного сообщения.

**Сложности интеграции разных технических стеков.**

В крупных компаниях разные команды используют разные технологии: одни пишут на Java, другие на Python, третьи используют готовые SaaS-решения. Прямая интеграция между ними создает "спагетти-архитектуру" с огромным количеством связей, которая сложна в поддержке и развитии.

Kafka реализует паттерн **«шина данных» (Event Bus)**. Все системы общаются не напрямую друг с другом, а через Kafka.

**Протокол и контракт:** Единым протоколом общения становится «отправка/получение сообщений в топик Kafka».

**Слабая связанность (Loose Coupling):** Производителям данных (producers) все равно, кто и как потребляет их данные. Они просто публикуют события в топик. Новый потребитель (consumer) может быть подключен в любой момент без необходимости изменять код производителя.

Системы становятся независимыми друг от друга. Остановка или переделка одного consumer не влияет на работу producer или других потребителей.