Это выделенный кластер серверов для образования кворума-согласия и поддержки внутренних процессов Kafka. Благодаря этому инструменту мы можем управлять кластером Kafka: добавлять пользователей и топики, задавать им настройки.
**Apache ZooKeeper** играет критически важную, но часто недооцененную роль в инфраструктуре Kafka.

Если говорить просто, **ZooKeeper — это "мозг" или "дирижер" кластера Kafka**, который координирует и управляет всеми его компонентами.

Начиная с версии Kafka 2.8.0 (и окончательно в версии 3.0.0) ZooKeeper был удален, и его функции взял на себя сам Kafka, работая в режиме **KRaft (Kafka Raft metadata mode)**. Однако подавляющее большинство существующих продакшен-кластеров до сих пор используют ZooKeeper.

---
### 1. Основная задача ZooKeeper

ZooKeeper — это отдельный от Kafka высокопроизводительный сервис координации для распределенных систем. Его главные задачи — **хранение метаданных** и **координация** кластера Kafka.

![[kafka-image-zookeeper.png]]

Также Zookeeper помогает обнаружить сбои контроллера, выбрать новый и сохранить работоспособность кластера Kafka. А ещё он хранит в себе все авторизационные данные и ограничения или _Access Control Lists_ при работе консумеров и продюсеров с брокерами.
### 2. Конкретные функции ZooKeeper в Kafka

ZooKeeper отвечает за следующие ключевые аспекты:

1.  **Выбор Лидера (Leader Election):**
    * В Kafka данные в каждом партишне (partition) реплицируются на несколько брокеров.
    * Один из брокеров становится **лидером** (leader) для партишна — он обрабатывает все запросы на запись и чтение.
    * Остальные брокеры являются **последователями** (followers) — они только реплицируют данные с лидера.
    * **ZooKeeper назначает лидера** и отслеживает его "живучесть". Если лидер "падает", ZooKeeper немедленно выбирает нового лидера из числа последователей, обеспечивая бесперебойную работу.

2.  **Хранение метаданных кластера:**
    *   **Какие топики существуют?**
    *   **Сколько партишнов у каждого топика?**
    *   **Где находятся эти партишны** (на каких брокерах)? Кто является лидером для каждого партишна?
    *   **Конфигурации** топиков и брокеров.
    *   Список всех брокеров в кластере, их статус (жив/мертв).
    *   Вся эта информация хранится в ZooKeeper в виде иерархии **znodes** (что-то похожее на файлы и папки).

3.  **Контроль членства брокеров (Service Discovery):**
    * Когда брокер Kafka запускается, он регистрируется в ZooKeeper, создавая свой временный znode.
    * ZooKeeper постоянно отслеживает "heartbeat" (пульс) каждого брокера через эти временные znodes. Если брокер перестает отвечать (например, из-за сбоя), его znode автоматически удаляется, и кластер узнает о его недоступности.

4.  **Контроль квот (Access Control):**
    * ZooKeeper может хранить списки контроля доступа (ACLs) для топиков, определяя, кто имеет право читать или писать в них.

5.  **Координация потребителей (Consumer Groups):**
    * В старых версиях Kafka (до использования встроенного механизма смещений `__consumer_offsets`) ZooKeeper также хранил информацию о том, какие сообщения уже были consumed каждой группой потребителей.

### 3. Как выглядит взаимодействие?

1. **Брокер Kafka** при старте подключается к ансамблю ZooKeeper и регистрируется там.
2. **Производитель (Producer)** перед отправкой сообщений спрашивает у любого известного ему брокера: "Куда мне писать сообщения для топика X?". Брокер, в свою очередь, запрашивает у ZooKeeper актуальные метаданные и отвечает производителю.
3. **Потребитель (Consumer)** при подключении также узнает у брокеров (которые спросили у ZooKeeper), где находятся лидеры для нужных ему партишнов.
4. Весь кластер постоянно сообщает ZooKeeper о своем состоянии.

### 4. Архитектура: Ансамбль ZooKeeper

ZooKeeper сам по себе является распределенной системой и обычно развертывается в виде **ансамбля (кворума)** из нечетного количества серверов (3, 5, 7). Это обеспечивает отказоустойчивость: кластер ZooKeeper продолжит работу, если работоспособно большинство серверов (например, 2 из 3 или 3 из 5).

---
### 5. Эра без ZooKeeper: режим KRaft

Начиная с версии **Kafka 3.0+**, Kafka может работать полностью **без ZooKeeper**, используя встроенный механизм управления метаданными на основе алгоритма **Raft** (отсюда и название **KRaft**).

**Почему отказываются от ZooKeeper?**

* **Сложность:** Требуется настраивать и поддерживать две отдельные распределенные системы (Kafka и ZooKeeper).
* **Производительность:** ZooKeeper мог становиться узким местом (bottleneck) при очень большом количестве партишнов, так как все метаданные проходили через него.
* **Масштабируемость:** В архитектуре с ZooKeeper метаданные и данные масштабируются по-разному. В KRaft это единая система.
* **Быстрое восстановление:** Перевыбор лидера в KRaft происходит быстрее.

В режиме **KRaft** сами брокеры Kafka (точнее, специально выделенные для этого **Controller**-брокеры) берут на себя все функции координации, используя отказоустойчивый протокол Raft для репликации метаданных между собой.

---
### Краткое сравнение

| Аспект                 | **С ZooKeeper (до версии 3.0)**             | **Без ZooKeeper (KRaft, версия 3.0+)**        |
| :--------------------- | :------------------------------------------ | :-------------------------------------------- |
| **Архитектура**        | Две системы: Kafka + ZooKeeper              | Одна система: только Kafka                    |
| **Координация**        | ZooKeeper — "мозг", хранит метаданные       | Встроенные **Controller**-ноды Kafka — "мозг" |
| **Сложность**          | Выше (настройка и поддержка двух кластеров) | Ниже (только один кластер)                    |
| **Производительность** | Может быть узким местом для метаданных      | Лучшая масштабируемость и производительность  |
| **Рекомендация**       | Для существующих кластеров, миграция        | **Для всех новых развертываний**              |

**Вывод:** В традиционной инфраструктуре Kafka **ZooKeeper был центральным координатором**, обеспечивающим согласованность, отказоустойчивость и надежность всего кластера. Однако современный тренд — отказ от него в пользу более простой и производительной встроенной архитектуры **KRaft**.