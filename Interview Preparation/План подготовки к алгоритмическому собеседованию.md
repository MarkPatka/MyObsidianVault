### **Блок 1: Фундаментальные основы (2-3 дня)**

#### 1.1 Временная и пространственная сложность

**Цель:** Уверенно анализировать любой алгоритм

1. Изучите Big O, Omega, Theta notation (30 мин)
2. Разберите сложность базовых операций: массивы, списки, хеш-таблицы (1 час)
3. Практика анализа:
    - Вложенные циклы с разными границами
    - Рекурсивные функции (Master Theorem)
    - Амортизированная сложность (динамические массивы)
4. Решите 5-7 задач на LeetCode, анализируя сложность каждого решения
5. Научитесь объяснять trade-offs между временем и памятью вслух

**Ключевые темы:**

- O(n log n) vs O(n²)
- Когда O(n) может быть хуже O(log n) в реальности
- Space complexity в рекурсии (стек вызовов)

---

### **Блок 2: Структуры данных (3-4 дня)**

#### 2.1 Базовые структуры данных в C#

**День 1-2: Хеширование**

1. `Dictionary<TKey, TValue>`:
    - Внутреннее устройство (хеш-функция, коллизии, rehashing)
    - Сложность операций (average vs worst case)
    - Реализуйте простую хеш-таблицу с нуля (для понимания)
2. `HashSet<T>`:
    - Отличия от Dictionary
    - Операции множеств (Union, Intersect, Except)
3. Решите 10 задач с тегами "Hash Table" на LeetCode (Easy → Medium)

**День 3: Очереди и стеки**

1. `Stack<T>`, `Queue<T>`, `PriorityQueue<TElement, TPriority>` (.NET 6+)
2. Когда использовать каждую структуру
3. Реализуйте MinStack, MaxQueue
4. Решите 5 задач на Stack/Queue

**День 4: LinkedList и дополнительные структуры**

1. `LinkedList<T>` - двусвязный список
2. Когда предпочесть List<T> или LinkedList<T>
3. SortedSet<T>, SortedDictionary - деревья в .NET
4. Решите 5 задач на Linked List

#### 2.2 Деревья (4-5 дней)

**День 1: Основы**

1. Терминология: корень, листья, высота, глубина, поддерево
2. Типы деревьев: бинарные, BST, полные, сбалансированные
3. Реализуйте класс TreeNode:

```csharp
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int val=0) { this.val = val; }
}
```

**День 2: Обходы деревьев**

1. Реализуйте все обходы (DFS):
    - Preorder (корень → левый → правый)
    - Inorder (левый → корень → правый) - дает отсортированный порядок для BST
    - Postorder (левый → правый → корень)
2. Рекурсивная и итеративная версии (со стеком)
3. BFS (Level-order traversal) с очередью
4. Решите 3 задачи на каждый тип обхода

**День 3: Binary Search Tree (BST)**

1. Свойства BST
2. Операции: поиск, вставка, удаление
3. Валидация BST
4. Решите 7-10 задач на BST

**День 4-5: Продвинутые темы**

1. Lowest Common Ancestor (LCA)
2. Сериализация/десериализация дерева
3. Построение дерева из обходов (inorder + preorder)
4. Balanced trees (AVL концепция, не обязательно реализация)
5. Trie (префиксное дерево) - часто встречается
6. Решите 10-15 задач Medium уровня

---

### **Блок 3: Алгоритмы сортировки и поиска (2 дня)**

#### 3.1 Сортировки

1. Реализуйте и проанализируйте:
    - QuickSort (O(n log n) avg, O(n²) worst) - часто спрашивают
    - MergeSort (O(n log n) stable)
    - HeapSort (O(n log n) in-place)
    - Для понимания: BubbleSort, InsertionSort
2. Когда использовать `Array.Sort()` vs `List.Sort()` vs LINQ `OrderBy()`
3. Stability в сортировках - что это и почему важно
4. Custom comparers в C#: `IComparer<T>`, `Comparison<T>`

#### 3.2 Бинарный поиск 

1. Классический binary search в отсортированном массиве
2. Шаблоны бинарного поиска:
    - Поиск точного значения
    - Поиск первого/последнего вхождения
    - Поиск в rotated sorted array
3. Binary search на ответ (часто встречается!)
4. Решите 15-20 задач с тегом "Binary Search"

---

### **Блок 4: Ключевые техники и паттерны (5-7 дней)**

#### 4.1 Two Pointers (1 день)

1. Встречное движение (left/right)
2. Быстрый/медленный указатель (Floyd's cycle detection)
3. Sliding window (фиксированный и переменный размер)
4. Решите 10-12 задач

#### 4.2 Sliding Window (1 день)

1. Фиксированное окно
2. Динамическое окно (расширение/сжатие)
3. Использование HashMap для подсчетов
4. Решите 8-10 задач

#### 4.3 Рекурсия и Backtracking (2 дня)

1. Базовая рекурсия и база
2. Backtracking шаблон:
    - Генерация всех подмножеств
    - Перестановки и комбинации
    - N-Queens, Sudoku solver
3. Решите 10-15 задач

#### 4.4 Динамическое программирование (2-3 дня)

**День 1: Основы**

1. Что такое DP: оптимальная подструктура + overlapping subproblems
2. Мемоизация (top-down) vs табуляция (bottom-up)
3. Классические задачи:
    - Fibonacci (для понимания принципа)
    - Climbing Stairs
    - House Robber
4. Решите 5 простых задач

**День 2: 1D DP**

1. Паттерн: `dp[i]` зависит от `dp[i-1]`, `dp[i-2]` и т.д.
2. Задачи:
    - Longest Increasing Subsequence
    - Coin Change
    - Decode Ways
3. Решите 7-10 задач

**День 3: 2D DP**

1. Паттерн: `dp[i][j]` - матрица состояний
2. Задачи:
    - Longest Common Subsequence
    - Edit Distance
    - Unique Paths
    - Knapsack problem
3. Решите 7-10 задач Medium/Hard

---

### **Блок 5: Графы (2-3 дня)**

#### 5.1 Основы графов

1. Представления: adjacency list, adjacency matrix
2. В C# используйте: `Dictionary<int, List<int>>` или `List<List<int>>`
3. DFS на графах (рекурсия и итерация)
4. BFS на графах
5. Решите 5-7 базовых задач

#### 5.2 Продвинутые темы

1. Топологическая сортировка (Kahn's algorithm)
2. Поиск циклов (Union-Find)
3. Shortest path (Dijkstra концептуально)
4. Решите 5-7 задач Medium

---

### **Блок 7: C#-специфичные знания (1-2 дня)**

#### 7.1 LINQ и производительность

1. Когда LINQ эффективен, когда нет
2. Отложенное выполнение (deferred execution)
3. `ToList()`, `ToArray()` - когда материализовать
4. Частые ошибки: multiple enumeration

#### 7.2 Полезные C# фичи для алгоритмов

1. `Span<T>`, `Memory<T>` - для производительности
2. `StringBuilder` для работы со строками
3. `ValueTuple` для возврата нескольких значений
4. Pattern matching для чистого кода
5. `ref`, `in`, `out` для оптимизации

#### 7.3 Unit-тестирование (xUnit)

1. Структура теста AAA (Arrange-Act-Assert)
2. Создайте test project для ваших решений
3. Параметризованные тесты: `[Theory]`, `[InlineData]`
4. Mocking с Moq (если потребуется на техническом)
5. Напишите тесты для 5-10 решенных задач

---

## **Оптимальный timeline на 4-6 недель:**

**Недели 1-2:**

- Дни 1-3: Сложность + базовые структуры данных
- Дни 4-8: Деревья (углубленно)
- Дни 9-10: Сортировки и бинарный поиск
- Дни 11-14: Two Pointers, Sliding Window, начало практики

**Недели 3-4:**

- Дни 15-17: Рекурсия и Backtracking
- Дни 18-21: Динамическое программирование (основной фокус)
- Дни 22-24: Графы
- Дни 25-28: Интенсивная практика LeetCode (50+ задач)

**Недели 5-6:**

- Ежедневно: 5-7 задач Medium, 1 Hard
- Mock interviews (с друзьями или на Pramp/Interviewing.io)
- Повторение слабых мест
- C#-специфика и тесты
