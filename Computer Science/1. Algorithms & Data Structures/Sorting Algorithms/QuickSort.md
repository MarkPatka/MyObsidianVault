#### Наивный Quick Sort
```csharp
public void QuickSort(int left, int right) 
{  
	int l = left;  
	int r = right;  
	int avg = array[(l + r) / 2)];
	
	do    
	{      
		while (array[l] < avg)       
			++l;      
		while (array[r] > avg)       
			--r;      
		if (l <= r)       
		{         
			if (l < r)           
			{             
				int temp = array[l];             
				array[l] = array[r];             
				array[r] = temp;           
			}         
			++l;         
			--r;        
		}     
	}    
	while (l <= r);  
			
	if (left < r)    
		QuickSort(left, r);  
	if (l < right)    
		QuickSort(l, right);}
```

**Вышеописанный алгоритм сортировки имеет следующие недостатки:**  

1. Поскольку опорный элемент выбирается как середина массива, то возможен случай, когда это будет всегда максимум, в результате чего массив будет разбиваться на две части длинною n — 1 и 1 и скорость алгоритма деградирует до O(n2);
2. При вышеописанных условиях глубина рекурсии достигает O(n), в результате чего при больших n может произойти переполнение программного стека;
3. Алгоритм неустойчив, то есть он меняет элементы с одинаковыми значениями. На примере сортировки чисел это ни как не сказывается, но если мы сортируем массив объектов по какому-либо свойству то это существенно, так как в результате нескольких вызовов метода Sort будем получать массив элементы которого отличаются порядком.
