![[apigateway_2.png]]
## Контекст

Представьте, что вы создаёте интернет-магазин на основе архитектурного паттерна микросервисов и реализуете страницу с деталями товара. Необходимо разработать несколько версий пользовательского интерфейса для страницы товара:

- HTML5/JavaScript‑интерфейс для настольных и мобильных браузеров — HTML генерируется серверным веб‑приложением.
- Нативные клиенты для Android и iPhone — эти клиенты взаимодействуют с сервером через REST API.

Кроме того, магазин должен предоставлять детали товара через REST API для сторонних приложений.

Страница с деталями товара может отображать большое количество информации. Например, страница деталей книги на Amazon.com для POJOs in Action показывает:

- Основную информацию о книге: название, автора, цену и т. п.
- Историю ваших покупок этой книги
- Наличие на складе
- Варианты покупки
- Другие товары, которые часто покупают вместе с этой книгой
- Другие товары, купленные клиентами, которые покупали эту книгу
- Отзывы клиентов
- Рейтинг продавцов
- …

Поскольку магазин использует микросервисную архитектуру, данные страницы деталей распределены по нескольким сервисам. Например:

- Сервис информации о продукте — основная информация о товаре (название, автор и т. п.)
- Сервис цен — цена товара
- Сервис заказов — история покупок товара
- Сервис инвентаря — наличие товара
- Сервис отзывов — отзывы клиентов
- …

Соответственно, код, отображающий страницу товара, должен получать информацию из всех этих сервисов.

## Проблема

Как клиенты приложения, основанного на микросервисах, получают доступ к отдельным сервисам?

## Факторы, влияющие на решение

- Гранулярность API микросервисов часто отличается от потребностей клиента. Микросервисы обычно предоставляют недетализированные API, поэтому клиенту приходится обращаться к нескольким сервисам. Например, для получения всех деталей товара клиенту нужно собрать данные из множества сервисов.
  
- Разные клиенты нуждаются в разной информации. Например, версия страницы для настольного браузера обычно более подробна, чем мобильная версия.
  
- Сетевые характеристики различаются для разных типов клиентов. Мобильная сеть обычно медленнее и с большей задержкой, чем немобильная сеть; WAN медленнее LAN. Серверное веб‑приложение может делать множество запросов к бэкенд‑сервисам без сильного влияния на UX, тогда как мобильный клиент может позволить лишь несколько запросов.
  
- Количество экземпляров сервисов и их расположение (хост+порт) меняются динамически.
  
- Разбиение на сервисы может изменяться со временем и должно быть скрыто от клиентов.
  
- Сервисы могут использовать разные протоколы, некоторые из которых не очень «веб‑дружелюбны».

## Решение

Реализовать API‑шлюз (API gateway), являющийся единой точкой входа для всех клиентов. API‑шлюз обрабатывает запросы двумя способами: 
- Часть запросов просто проксируется/маршрутизируется к соответствующему сервису; 
- Другие запросы обрабатываются через «вилку» (fan‑out) — агрегируются данные от нескольких сервисов.

API‑шлюз также может реализовывать безопасность, например, проверку авторизации клиента на выполнение запроса.

![[apigateway_1.jpg]]
Вариация: [[BFF (Backend for Frontend)|Backend for Frontend]]

## Результаты использования

### Преимущества использования API‑шлюза:

- Изолирует клиентов от того, как приложение разделено на микросервисы.
- Изолирует клиентов от задачи определения расположения экземпляров сервисов.
- Предоставляет оптимальный API для каждого клиента.
- Уменьшает количество запросов/кругов «запрос–ответ». Например, API‑шлюз позволяет клиентам получить данные из нескольких сервисов за один круг. Меньше запросов — меньше оверхеда и лучше UX. API‑шлюз обязателен для мобильных приложений.
- Упрощает клиент, перемещая логику вызова нескольких сервисов из клиента в API‑шлюз.
- Транслирует «стандартный» публичный веб‑дружелюбный протокол в те протоколы, которые используются внутри.

### Недостатки паттерна API‑шлюза:

- Повышенная сложность — API‑шлюз — ещё одна составляющая, которую нужно разрабатывать, деплоить и управлять.
- Увеличение времени отклика из‑за дополнительного сетевого перехода через API‑шлюз — однако для большинства приложений стоимость одного дополнительного раунда несущественна.

