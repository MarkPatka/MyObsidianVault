В противоположность [[SAGA]], которая полагается на компенсируемую последовательность, протокол **двухфазного коммита (2PC)** стремится сохранить семантику _единой атомарной транзакции_ даже в распределённой системе. 2PC – это классический алгоритм координации транзакции между несколькими узлами (базами данных, сервисами) с помощью централизованного координатора. Его цель – добиться, чтобы все участники либо **зафиксировали** изменения, либо **отменили**, и ни один не остался “в стороне”.

![[two-phased-commit_1.png]]

#### Принцип работы 2PC

Как следует из названия, протокол выполняется в **две фазы**. Предположим, у нас есть несколько участников (например, два разных сервиса или две базы данных), которые должны выполнить атомарно серию операций. Для координации назначается специальный компонент – координатор транзакции. 

Алгоритм такой:

1. **Фаза подготовки (prepare phase, фаза голосования):** Координатор рассылает всем участникам запрос на подготовку к коммиту. Каждый участник локально выполняет свою часть работы транзакции (например, делает необходимые изменения в своей БД) **но не фиксирует их**, а помечает как “готовые к коммиту” (в базах данных это обычно означает записать изменения в журнал и заблокировать ресурсы). После этого участник отвечает координатору либо **“готов” (Yes)**, если его этап прошёл успешно и он готов зафиксировать, либо **“не могу” (No)**, если произошла ошибка и он не сможет закоммитить. Все участники по сути голосуют “за” или “против” общей фиксации.
    
2. **Фаза фиксации (commit phase):** Координатор собирает ответы. Если **все** участники ответили "готов/Yes", то координатор посылает команду **Commit** всем участникам. Каждый участник получает эту команду и выполняет фиксацию своих изменений (окончательно применяет их в своей системе). Если хотя бы один участник ответил отказом ("No"), либо не ответил из-за сбоя, координатор посылает команду **Rollback** всем тем, кто был готов. В результате все участники отменят свои изменения (или не будут фиксировать). Таким образом, достигается атомарность: либо все commit, либо все rollback.

После завершения второй фазы координатор может сообщить инициатору (например, приложению, начавшему транзакцию), что транзакция успешно выполнена или откатилась.

```javascript
class TransactionCoordinator 
{    
	private List<Participant> participants = new ArrayList<>();  
	 
	public void addParticipant(Participant p) {        
		participants.add(p);    
	}  
	  
	// Фаза подготовки: возвращает true, если все участники готовы   
	public boolean prepareAll() {        
		for (Participant p : participants) {           
			if (!p.prepare()) {                
				return false; // хотя бы один не смог подготовиться 
			}        
		}        
		return true;    
	}
	
	// Фаза коммита: разослать команду фиксации   
	public void commitAll() {        
		for (Participant p : participants) {            
			p.commit();        
		}    
	}    
	
	// Откат: разослать команду rollback    
	public void rollbackAll() {        
		for (Participant p : participants) {            
			p.rollback();        
		}    
	}
}

class Participant {    
	private String name;    
	private boolean prepared = false;    
	public Participant(String name) { this.name = name; }    
	
	// Локальная подготовка   
	 public boolean prepare() {        
		 // ... выполнить необходимые действия и застолбить изменения (без коммита)        
		 // Например, заблокировать строки БД, записать журнал. 
		 prepared = true; // допустим, подготовка всегда успешна для примера 
		 System.out.println(name + " готов к коммиту.");        
		 return prepared;    
	 }
	     
	public void commit() {        
		if (prepared) {            
		// ... зафиксировать изменения           
		System.out.println(name + " фиксирует транзакцию.");        
		}    
	}    

	public void rollback() {        
	// ... откатить изменения (если были сделаны)       
	System.out.println(name + " откатывает транзакцию.");    
	}
}

// Использование:
TransactionCoordinator coord = new TransactionCoordinator();
coord.addParticipant(newParticipant("Database1"));
coord.addParticipant(new Participant("Database2"));

if (coord.prepareAll()) {     
	// запросить всех на подготовку    
	coord.commitAll();         
	// все готовы -> коммит всем
} 
else {    
	coord.rollbackAll();// кто-то не готов -> откат всем готовившимся
}
```

#### Применение 2PC и поддержка инструментов

Протокол 2PC широко применялся в традиционных корпоративных приложениях, особенно до эры микросервисов. Типичные места, где встречается 2PC:

- **Распределённые реляционные БД:** Например, транзакция затрагивает две разные базы данных (две СУБД или два соединения). В Java для этого есть JTA (Java Transaction API) и XA-драйверы – координатор (Narayana, Atomikos и др.) обеспечивает двухфазный коммит между базами.
    
- **Комбинация база данных + очередь сообщений:** Частый кейс – нужно записать данные в БД **и** отправить сообщение в брокер (например, в Kafka, RabbitMQ) атомарно. Некоторые брокеры/JMS поддерживают XA-транзакции, позволяя участовать в 2PC наряду с БД. Тогда либо обе операции выполняются, либо нет (избегая ситуации “записали в БД, но сообщение потеряли” или наоборот).
    
- **Классические монолитные системы с несколькими ресурсами:** Транзакция, обновляющая несколько субсистем (например, две БД, или БД и файловую систему), также могла координироваться через 2PC.

Для реализации 2PC необходима **поддержка со стороны всех участников**. Каждый ресурс должен обладать интерфейсом приготовления/фиксации. В мире реляционных БД это стандарт XA; в NoSQL-хранилищах или пользовательских сервисах такой поддержки часто нет. Поэтому в чистых микросервисах, где сервисы гетерогенны, самостоятельно реализовывать 2PC сложно – нужно либо писать слой-адаптер для каждого (чтобы сервисы умели принимать команды prepare/commit), либо ограничиться теми ресурсами, что уже поддерживают XA. Существуют готовые менеджеры транзакций (координаторы) – упомянутые **Atomikos**, **Narayana**, **Bitronix** и пр., которые можно встроить в приложение и сконфигурировать ресурсы для участия в глобальной транзакции. Но это тянет за собой серьезные ограничения.

#### Ограничения и недостатки двухфазного коммита

Хотя 2PC гарантирует строгую согласованность, в распределённых системах он имеет известные недостатки:

- **Блокировка ресурсов и производительность:** На фазе подготовки каждый участник обычно **блокирует изменяемые ресурсы** (например, строки в базе) до получения команды commit или rollback. Если участников много, и они ждут друг друга, это может затормозить систему. В случае задержек или сбоев ожидание может быть длительным, и заблокированные ресурсы недоступны другим транзакциям – снижая параллелизм. 2PC поэтому плохо масштабируется с ростом числа участников: задержка одного узла удерживает всех.
    
- **Точка отказа – координатор:** Координатор транзакции – центральный “командир”. Если он выйдет из строя в неподходящий момент, участники останутся в подвешенном состоянии. Например, участники подготовились и ответили “Yes”, ждут команду, а координатор умер или потерял связь – они не знают, коммитить им или откатывать. Такая ситуация называется **блокировкой (blocking)** в 2PC. В базах данных участники в ожидании решения могут держать транзакцию открытой очень долго. Требуется администратор или специальный механизм восстановления координатора, чтобы решить судьбу транзакции. Существуют расширения (протокол трехфазного коммита, 3PC) для смягчения этой проблемы, но полностью без координатора 2PC не работает.
    
- **Оверхед на коммуникацию:** 2PC требует два раунда сетевого взаимодействия (broadcast prepare, затем broadcast commit/rollback). В условиях высокой нагрузки или сетевых задержек это добавляет значительный оверхед к каждой транзакции. Saga же, напротив, чаще работает асинхронно, и шаги могут выполняться без центральной синхронизации.
    
- **Слабая приспособленность к отказам связи:** Если один из участников недоступен, координатор не получит от него “готов”, и вся транзакция должна откатиться (ради консистентности жертвуем доступностью). В микросервисах, где отказ отдельного сервиса не редкость, 2PC приводит к более частым отказам всей операции по сравнению с Saga, которая могла бы дождаться восстановления сервиса и продолжить (или выполнить компенсации).
    
- **Сложность внедрения в микросервисах:** Применение 2PC между независимыми сервисами идёт вразрез с философией слабой связанности. Все участники должны быть “подчинены” общему координатору и протоколу. Это усложняет архитектуру – фактически получается распределённый монолит на уровне транзакций. Поэтому многие избегают 2PC в микросервисной архитектуре, предпочитая _eventual consistency_ подходы (Saga, TCC и пр.).
    

Следует отметить, что 2PC остаётся полезным в ограниченных сценариях, где **небольшое число участников** и **жёсткое требование атомарности**. К примеру, финансовые операции между двумя банковскими системами могут использовать двухфазный коммит, если наличие центрального координатора приемлемо. Но во внутренней архитектуре современных веб-сервисов 2PC – редкий гость; чаще его заменяют на паттерны, обеспечивающие “логическую” атомарность, как Saga.

### Сравнение Saga и 2PC

Оба рассматриваемых подхода стремятся решить одну проблему – поддержать согласованность данных в распределённой среде, но делают это по-разному. Сведём ключевые отличия в таблицу:

| **Критерий**                      | **Saga (Сага)**                                                                                                                                                                                                                                                                                                                             | **2PC (двухфазный коммит)**                                                                                                                                                                                                                                                                                                              |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Модель согласованности**        | _Конечная согласованность_ (eventual consistency): данные приводятся к консистентному состоянию после выполнения всех шагов. Промежуточно возможна рассинхронизация, которая исправляется компенсирующими действиями.                                                                                                                       | _Строгая, мгновенная согласованность_: либо все участники сразу фиксируют изменения, либо ни один (атомарность на уровне протокола). В момент завершения транзакции все данные согласованы.                                                                                                                                              |
| **Тип транзакции**                | Набор _локальных_ транзакций + компенсации. Каждый сервис работает автономно, глобальная "транзакция" – это последовательность шагов.                                                                                                                                                                                                       | _Единая глобальная транзакция_, распределённая на участников. Есть понятие начала и конца общей транзакции, охватывающей все узлы.                                                                                                                                                                                                       |
| **Обработка сбоев**               | Сага _толерантна к частичным сбоям_: при ошибке на шаге выполняются компенсирующие транзакции для отмены ранее выполненных действий. Система возвращается к предыдущему консистентному состоянию.                                                                                                                                           | 2PC полагается на _централизованный откат_: при сбое любого участника координатор отменяет **всю** транзакцию (ни у кого не фиксируется). Если сбой произошёл после фазы подготовки, необходим координатор (или админ) для разрешения.                                                                                                   |
| **Задержки и производительность** | _Низкие задержки на этапах_: каждый шаг – быстрый локальный коммит, сервисы могут работать асинхронно. Общий процесс может занять время (особенно если много шагов), но при нормальной работе шаги не блокируют друг друга глобально.                                                                                                       | _Высокие задержки_: требуется два раунда согласования. Участники вынуждены ждать команды координатора, удерживая ресурсы. Для каждой транзакции накладные расходы на координацию, что замедляет прохождение операций.                                                                                                                    |
| **Скалируемость системы**         | _Высокая_: Saga не требует глобальных блокировок. С ростом числа сервисов сложность процессов увеличивается, но нет общей точки, где все должны синхронизироваться одновременно (особенно при хореографии). Можно параллелить независимые саги.                                                                                             | _Ограниченная_: Большое число участников делает координацию тяжёлой – координатор становится узким местом, ресурсы блокируются. Масштабирование по числу параллельных глобальных транзакций ограничено пропускной способностью координатора и сети.                                                                                      |
| **Отказоустойчивость**            | _Без единой точки отказа_: выход из строя отдельного сервиса приводит к компенсациям, но остальные сервисы могут продолжать другие задачи. Сбой оркестратора (при его наличии) требует механизма восстановления состояния саги, однако систему можно спроектировать так, чтобы сага либо дождалась восстановления сервиса, либо откатилась. | _Зависимость от координатора_: выход из строя координатора или потеря связи могут оставить систему в неопределённости (подготовлено, но не зафиксировано). Участники сами по себе решение принять не могут – требуется восстановить координатор. То есть отказ одного компонента (координатора) ставит под угрозу всю транзакцию.        |
| **Поддержка технологиями**        | _На уровне приложения_: Не требует специальных возможностей от БД, кроме локальных транзакций. Реализуется через код приложения, фреймворки Saga, очереди сообщений. Широко поддерживается концептуально – вендор-независимо.                                                                                                               | _На уровне инфраструктуры_: Требует поддержки протокола 2PC (XA) от всех участников (СУБД, брокеров). Нужен внешний или встроенный менеджер транзакций. В Java-мире существуют готовые реализации (JTA, Atomikos, etc.), но их настройка усложняет архитектуру. Многие современные NoSQL или REST-сервисы не умеют быть участниками 2PC. |
| **Примеры случаев использования** | Сложные бизнес-процессы в e-commerce (обработка заказов, платежей, доставки), бронирование путешествий (последовательное резервирование разных услуг), где важно выполнить все шаги или откатить. Подходит, когда операции можно компенсировать.                                                                                            | Банковские переводы между счетами в разных системах (требуют абсолютной атомарности), распределённые транзакции в нескольких базах данных (например, распределённый SQL). Иногда применяется внутри монолитов или крупных корпоративных систем, где сильная консистентность важнее производительности.                                   |

