## Основные типы данных Oracle

|Тип данных|Описание|Примеры значений|
|---|---|---|
|**VARCHAR2(n)**|Строка переменной длины (до 4000 байт)|'Привет', 'Oracle'|
|**CHAR(n)**|Строка фиксированной длины (до 2000 байт)|'AB ', 'CODE'|
|**NUMBER(p,s)**|Числовой тип (p - точность, s - масштаб)|123.45, 1000000|
|**DATE**|Дата и время (с точностью до секунды)|'01-JAN-2024'|
|**TIMESTAMP**|Дата и время с долями секунд|'01-JAN-24 10:30:45.123'|
|**CLOB**|Большой текстовый объект (до 4 ГБ)|Длинные тексты|
|**BLOB**|Большой бинарный объект (до 4 ГБ)|Изображения, файлы|
|**RAW(n)**|Бинарные данные (до 2000 байт)|Хеши, токены|
|**LONG**|Длинный текст (устаревший, до 2 ГБ)|Старые системы|
|**ROWID**|Физический адрес строки|AAARfmAABAAADm5AAA|
|**BINARY_FLOAT**|32-битное число с плавающей точкой|3.14159f|
|**BINARY_DOUBLE**|64-битное число с плавающей точкой|2.71828d|

## Синтаксические особенности Oracle (отличия от PostgreSQL и MS SQL)

| Особенность               | Oracle                              | PostgreSQL                     | MS SQL                           |
| ------------------------- | ----------------------------------- | ------------------------------ | -------------------------------- |
| **Конкатенация строк**    | `'A'                                |                                | 'B'`или`CONCAT()`                |
| **Автоинкремент**         | `SEQUENCE` + триггер или `IDENTITY` | `SERIAL`, `IDENTITY`           | `IDENTITY`                       |
| **Пустая строка**         | `''` = `NULL`                       | `''` ≠ `NULL`                  | `''` ≠ `NULL`                    |
| **Ограничение выборки**   | `ROWNUM` или `FETCH FIRST`          | `LIMIT`                        | `TOP` или `OFFSET-FETCH`         |
| **Получение даты**        | `SYSDATE` или `CURRENT_DATE`        | `CURRENT_DATE`, `NOW()`        | `GETDATE()`, `CURRENT_TIMESTAMP` |
| **Извлечение подстроки**  | `SUBSTR(str, start, len)`           | `SUBSTRING(str, start, len)`   | `SUBSTRING(str, start, len)`     |
| **Преобразование NULL**   | `NVL(col, default)`                 | `COALESCE(col, default)`       | `ISNULL(col, default)`           |
| **Иерархические запросы** | `CONNECT BY` (уникально)            | `WITH RECURSIVE`               | `WITH` (CTE)                     |
| **Dual таблица**          | `SELECT * FROM DUAL`                | Не требуется                   | Не требуется                     |
| **Формат даты**           | `TO_CHAR(date, 'DD-MON-YYYY')`      | `TO_CHAR(date, 'DD-Mon-YYYY')` | `FORMAT(date, 'dd-MMM-yyyy')`    |
| **Добавление месяцев**    | `ADD_MONTHS(date, n)`               | `date + INTERVAL 'n months'`   | `DATEADD(month, n, date)`        |

## Примеры запросов

### 1. Простой INNER JOIN

```sql
-- Получение заказов с информацией о клиентах
SELECT 
    o.order_id,
    o.order_date,
    c.customer_name,
    c.email,
    o.total_amount
FROM orders o
INNER JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= ADD_MONTHS(SYSDATE, -3)
ORDER BY o.order_date DESC;
```

### 2. Сложный запрос с LEFT JOIN и подзапросом

```sql
-- Клиенты с их последним заказом и общим количеством заказов
SELECT 
    c.customer_id,
    c.customer_name,
    c.city,
    lo.last_order_date,
    lo.last_order_amount,
    NVL(oc.total_orders, 0) AS total_orders,
    NVL(oc.lifetime_value, 0) AS lifetime_value
FROM customers c
LEFT JOIN (
    -- Подзапрос для получения последнего заказа
    SELECT 
        customer_id,
        MAX(order_date) AS last_order_date,
        MAX(total_amount) KEEP (DENSE_RANK LAST ORDER BY order_date) AS last_order_amount
    FROM orders
    GROUP BY customer_id
) lo ON c.customer_id = lo.customer_id
LEFT JOIN (
    -- Подзапрос для подсчета общих метрик
    SELECT 
        customer_id,
        COUNT(*) AS total_orders,
        SUM(total_amount) AS lifetime_value
    FROM orders
    GROUP BY customer_id
) oc ON c.customer_id = oc.customer_id
WHERE c.status = 'ACTIVE'
ORDER BY lifetime_value DESC NULLS LAST;
```

### 3. JOIN с агрегатными функциями и GROUP BY

```sql
-- Анализ продаж по категориям продуктов с рейтингом
SELECT 
    cat.category_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    COUNT(DISTINCT o.customer_id) AS unique_customers,
    SUM(oi.quantity) AS total_quantity_sold,
    ROUND(AVG(oi.unit_price), 2) AS avg_unit_price,
    ROUND(SUM(oi.quantity * oi.unit_price), 2) AS total_revenue,
    RANK() OVER (ORDER BY SUM(oi.quantity * oi.unit_price) DESC) AS revenue_rank
FROM categories cat
INNER JOIN products p ON cat.category_id = p.category_id
INNER JOIN order_items oi ON p.product_id = oi.product_id
INNER JOIN orders o ON oi.order_id = o.order_id
WHERE o.order_date BETWEEN ADD_MONTHS(SYSDATE, -12) AND SYSDATE
    AND o.status = 'COMPLETED'
GROUP BY cat.category_id, cat.category_name
HAVING SUM(oi.quantity * oi.unit_price) > 10000
ORDER BY total_revenue DESC;
```

### 4. Комплексный запрос с множественными JOIN и аналитическими функциями

```sql
-- Топ продуктов по регионам с накопительным итогом и процентом от общего
SELECT 
    r.region_name,
    p.product_name,
    cat.category_name,
    COUNT(DISTINCT o.order_id) AS order_count,
    SUM(oi.quantity) AS units_sold,
    ROUND(SUM(oi.quantity * oi.unit_price), 2) AS revenue,
    ROUND(AVG(oi.quantity * oi.unit_price), 2) AS avg_order_value,
    -- Процент от общей выручки региона
    ROUND(
        RATIO_TO_REPORT(SUM(oi.quantity * oi.unit_price)) 
        OVER (PARTITION BY r.region_id) * 100, 
        2
    ) AS pct_of_region_revenue,
    -- Накопительная сумма по региону
    ROUND(
        SUM(SUM(oi.quantity * oi.unit_price)) 
        OVER (
            PARTITION BY r.region_id 
            ORDER BY SUM(oi.quantity * oi.unit_price) DESC
            ROWS UNBOUNDED PRECEDING
        ),
        2
    ) AS cumulative_revenue,
    -- Ранг продукта в регионе
    DENSE_RANK() OVER (
        PARTITION BY r.region_id 
        ORDER BY SUM(oi.quantity * oi.unit_price) DESC
    ) AS product_rank_in_region
FROM regions r
INNER JOIN customers c ON r.region_id = c.region_id
INNER JOIN orders o ON c.customer_id = o.customer_id
INNER JOIN order_items oi ON o.order_id = oi.order_id
INNER JOIN products p ON oi.product_id = p.product_id
INNER JOIN categories cat ON p.category_id = cat.category_id
WHERE o.order_date >= ADD_MONTHS(SYSDATE, -6)
    AND o.status IN ('COMPLETED', 'SHIPPED')
GROUP BY 
    r.region_id,
    r.region_name,
    p.product_id,
    p.product_name,
    cat.category_name
HAVING SUM(oi.quantity * oi.unit_price) > 5000
ORDER BY 
    r.region_name,
    revenue DESC
FETCH FIRST 50 ROWS ONLY;
```

Эти примеры демонстрируют типичные возможности Oracle SQL, включая специфичные функции (`ADD_MONTHS`, `NVL`, `KEEP`), аналитические функции (`RANK`, `RATIO_TO_REPORT`), и современный синтаксис ограничения результатов (`FETCH FIRST`).