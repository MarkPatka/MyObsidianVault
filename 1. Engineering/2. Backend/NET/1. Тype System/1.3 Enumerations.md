---

---
## Перечисления 

Перечисление — это тип значения, который напрямую наследует от [System.Enum](https://learn.microsoft.com/ru-ru/dotnet/api/system.enum) и предоставляет альтернативные имена для значений базового типа-примитива. Тип перечисления имеет имя, базовый тип, который должен быть одним из встроенных целочисленных знаковых или беззнаковых типов (например, [Byte](https://learn.microsoft.com/ru-ru/dotnet/api/system.byte), [Int32](https://learn.microsoft.com/ru-ru/dotnet/api/system.int32) или [UInt64](https://learn.microsoft.com/ru-ru/dotnet/api/system.uint64)), а также набор полей. Поля являются статическими полями литералов, каждое из которых представляет константу. Одно значение можно присвоить нескольким полям. В этом случае необходимо пометить одно из значений как первичное значение перечисления для отражения и преобразования строк.

Значение базового типа можно присвоить перечислению и наоборот (среда выполнения не требует приведения типов). Можно создавать экземпляры перечислений и вызвать методы [System.Enum](https://learn.microsoft.com/ru-ru/dotnet/api/system.enum), а также любые методы, определенные в базовом типе перечисления. При этом в некоторых языках передача перечисления в виде параметра может не допускаться, если требуется передать экземпляр базового типа (или наоборот).

К перечислениям применяются следующие дополнительные ограничения.

- В них нельзя определять собственные методы.
- В них нельзя реализовывать интерфейсы.
- В них нельзя определять свойства и события.
- Они не могут быть универсальными, если только они становятся таковыми за счет вложения внутрь универсального типа. То есть перечисления не могут иметь свои собственные параметры типов.


## Хороший пример использования enum

`Size { Small, Medium, Large }`. Это хороший пример, потому что:
*   **Набор значений закрыт** (фиксирован): размеры вряд ли изменятся.
*   **Значения не имеют поведения**: они просто представляют собой факт, данные. Ваш код может использовать это значение, чтобы, например, выбрать цену из прайс-листа или URL изображения определенного размера. Само перечисление не "знает" об этой цене или URL.

```csharp
public enum Size { Small, Medium, Large }

// Где-то в другом месте кода
public decimal CalculatePrice(Size size)
{
    // Используем switch для получения данных на основе enum
    return size switch
    {
        Size.Small => 10.00m,
        Size.Medium => 15.00m,
        Size.Large => 20.00m,
        _ => throw new ArgumentOutOfRangeException(nameof(size))
    };
}
```

Пока таких мест в коде немного, это приемлемо.

## Плохой пример использования enum

**Проблема начинается, когда вы начинаете проверять значение enum в `if` или `switch` по всему коду для того, чтобы решить, *что делать*.** Это и есть использование enum для управления потоком выполнения.

**Представьте, что у нас есть система заказов и статусы:**

```csharp
public enum OrderStatus { Pending, Confirmed, Shipped, Delivered, Cancelled }
```

**Анти-пример (код с "запахом"):**

```csharp
// Код в сервисе оплаты
public void ProcessPayment(Order order)
{
    if (order.Status == OrderStatus.Pending)
    {
        // Списать деньги с карты
    }
    else if (order.Status == OrderStatus.Confirmed || order.Status == OrderStatus.Shipped)
    {
        // Ничего не делать, оплата уже обработана
    }
    else
    {
        throw new InvalidOperationException("Cannot process payment for this status.");
    }
}

// Код в сервисе доставки
public void ScheduleDelivery(Order order)
{
    switch (order.Status)
    {
        case OrderStatus.Confirmed:
            // Создать задание для курьера
            break;
        case OrderStatus.Shipped:
            // Проверить статус у курьера
            break;
        case OrderStatus.Delivered:
            // Отправить опрос о качестве доставки
            break;
        default:
            // Ничего не делать
            break;
    }
}

// Код в сервисе уведомлений
public void SendNotification(Order order)
{
    if (order.Status == OrderStatus.Confirmed)
    {
        // "Ваш заказ подтвержден!"
    }
    else if (order.Status == OrderStatus.Shipped)
    {
        // "Ваш заказ в пути!"
    }
    // ... и так далее для каждого статуса
}
```

### Почему это "code smell" и приводит к хрупкости?

1.  **Нарушение принципа Open/Closed (OCP):** Если вы захотите добавить новый статус `ReadyForPickup`, вам придется **прочесать весь код** и найти все места, где есть `if` или `switch` по `OrderStatus`, и добавить туда новую ветку. Это极易出错 (очень легко ошибиться).
2.  **Дублирование логики:** Одна и та же бизнес-логика (например, "что значит быть подтвержденным заказом?") размазана по десяткам мест в коде, а не инкапсулирована в одном.
3.  **Хрупкость (Fragility):** Код ломается от изменений. Одно небольшое изменение в перечислении (добавление нового значения) вызывает волну изменений по всему приложению.
4.  **Трудно тестировать:** Чтобы протестировать метод `ProcessPayment`, вам нужно знать все статусы, при которых он работает, и создать заглушки для всех сценариев. Логика тесно связана с конкретными значениями enum.


## Использование класса-перечисления вместо enum

Перечисления (или кратко _типы enum_) — это тонкая языковая оболочка для целочисленного типа. Их, возможно, стоит использовать только тогда, когда вы храните одно значение из закрытого набора значений. **Классификация по размерам (small, medium, large) — хороший пример.** Использование перечислений для управления потоком выполнения программы или для создания более сложных абстракций может быть [запахом кода](https://deviq.com/antipatterns/code-smells). Такой подход приводит к хрупкому коду с множеством операторов управления потоком, которые проверяют значения перечисления.

Вместо этого вы можете создавать **классы-перечисления (Enumeration classes)**, которые задействуют все богатые возможности объектно-ориентированного языка.

### Enumeration base class

``` C#
public abstract class Enumeration : IComparable
{
    public string Name { get; private set; }

    public int Id { get; private set; }

    protected Enumeration(int id, string name) => (Id, Name) = (id, name);

    public override string ToString() => Name;

    public static IEnumerable<T> GetAll<T>() where T : Enumeration =>
        typeof(T).GetFields(BindingFlags.Public |
                            BindingFlags.Static |
                            BindingFlags.DeclaredOnly)
                 .Select(f => f.GetValue(null))
                 .Cast<T>();

    public override bool Equals(object obj)
    {
        if (obj is not Enumeration otherValue)
        {
            return false;
        }

        var typeMatches = GetType().Equals(obj.GetType());
        var valueMatches = Id.Equals(otherValue.Id);

        return typeMatches && valueMatches;
    }

    public int CompareTo(object other) => Id.CompareTo(((Enumeration)other).Id);

    // Other utility methods ...
}
```

```C#
public class CardType : Enumeration
{
    public static CardType Amex = new(1, nameof(Amex));
    public static CardType Visa = new(2, nameof(Visa));
    public static CardType MasterCard = new(3, nameof(MasterCard));

    public CardType(int id, string name)
        : base(id, name)
    {
    }
}
```


### Enumeration Classes

Вместо того чтобы использовать "тупой" enum и размазывать логику по всему коду, предлагается создать класс для каждого элемента перечисления.

**Пример решения для статуса заказа:**

```csharp
// Базовый абстрактный класс для всех статусов
public abstract class OrderStatus
{
    public static readonly OrderStatus Pending = new PendingStatus();
    public static readonly OrderStatus Confirmed = new ConfirmedStatus();
    public static readonly OrderStatus Shipped = new ShippedStatus();
    // ... и т.д.

    public int Id { get; } // Для хранения в БД, как у enum
    public string Name { get; } // Для отображения

    protected OrderStatus(int id, string name)
    {
        Id = id;
        Name = name;
    }

    // Самое главное: абстрактные методы, определяющие поведение!
    public abstract bool CanProcessPayment();
    public abstract void ProcessDelivery(Order order);
    public abstract string GetNotificationMessage();

    // Вложенные приватные классы, реализующие каждый статус
    private class PendingStatus : OrderStatus
    {
        public PendingStatus() : base(0, "Pending") { }
        public override bool CanProcessPayment() => true;
        public override void ProcessDelivery(Order order) { /* логика для Pending */ }
        public override string GetNotificationMessage() => "Your order has been received.";
    }

    private class ConfirmedStatus : OrderStatus
    {
        public ConfirmedStatus() : base(1, "Confirmed") { }
        public override bool CanProcessPayment() => false; // Уже оплачен
        public override void ProcessDelivery(Order order) { /* Создать задание для курьера */ }
        public override string GetNotificationMessage() => "Your order is confirmed!";
    }
    // ... аналогично для других статусов
}
```

**Как теперь выглядит наш хрупкий код?**

```csharp
// Сервис оплаты
public void ProcessPayment(Order order)
{
    if (order.Status.CanProcessPayment()) // Логика инкапсулирована внутри класса статуса!
    {
        // Списать деньги с карты
    }
    else
    {
        throw new InvalidOperationException("Cannot process payment for this status.");
    }
}

// Сервис доставки
public void ScheduleDelivery(Order order)
{
    order.Status.ProcessDelivery(order); // Полиморфизм! Каждый статус сам знает, что делать.
}
```

**Преимущества такого подхода:**

*   **Соответствие OCP:** Чтобы добавить новый статус, вы создаете один новый класс. Вам **не нужно** изменять существующий код, который уже работает с `OrderStatus`.
*   **Инкапсуляция:** Вся логика, связанная с конкретным статусом, находится в одном месте — внутри его класса.
*   **Устранение "распыления" логики:** Исчезают гигантские `switch` и цепочки `if-else`.
*   **Полиморфизм:** Код использует полиморфное поведение, что является идиоматичным для ООП.
